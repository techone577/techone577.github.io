<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【LeetCode 377】 Combination Sum IV 组合总和 IV]]></title>
    <url>%2F2018%2F06%2F01%2F%5BLeetCode%20377%5DCombinatiion%20Sum%20IV%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20IV%2F</url>
    <content type="text"><![CDATA[[LeetCode 377]Combinatiion Sum IV 组合总和 IVProblem decription:Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example:123456789101112131415nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. Follow up:What if negative numbers are allowed in the given array?How does it change the problem?What limitation we need to add to the question to allow negative numbers? 题目描述：给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例:123456789101112131415nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 进阶：如果给定的数组中含有负数会怎么样？问题会产生什么变化？我们需要在题目中添加什么限制来允许负数的出现？ Solution：使用动态规划和递归均可，创建一个dp数组，dp[i]表示和为i的正整数组合的个数，dp[0]=1,则从i=1到target遍历，对每一个i遍历数组中每个num，若i&gt;=num,则dp[i]+=dp[i-num],表示dp[3]=dp[2]+1 或 dp[1]+2 或 dp[0]+3,将所有情况累加就是dp[3]的结果,对原数组排序可对算法进行优化，当i&lt;num后面则不用判断直接break。(后面给出递归版本) Code(动态规划)：12345678910111213141516//beat 90%class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int []dp=new int[target+1]; dp[0]=1; Arrays.sort(nums); for(int i=1;i&lt;target+1;i++)&#123; for(int num:nums)&#123; if(i&lt;num) break; dp[i]+=dp[i-num]; &#125; &#125; return dp[target]; &#125;&#125; Code(递归)：1234567891011121314//超时 class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int count=0; if(target==0) return 1; for(int num:nums)&#123; if(target&gt;=num) count+=combinationSum4(nums,target-num); &#125; return count; &#125;&#125; 123456789101112131415161718//AC beat 66.7%class Solution &#123; HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;(); public int combinationSum4(int[] nums, int target) &#123; int count=0; if(target==0) return 1; if(map.containsKey(target)) return map.get(target); for(int num:nums)&#123; if(target&gt;=num) count+=combinationSum4(nums,target-num); &#125; map.put(target,count); return count; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 394】 Decode String 字符串解码]]></title>
    <url>%2F2018%2F06%2F01%2F%5BLeetCode%20394%5DDecode%20String%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[[LeetCode 394]Decode String 字符串解码Problem decription:Given an encoded string, return it’s decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. Example:123s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;. 题目描述：给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例:s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;. s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;. s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;. Solution：首先想到的是递归，或者是用两个栈的非递归方法，非递归的效率更高一些。一个栈用来保存数字，一个用来保存字符串，以 b3[a]2[c]d] 为例,遍历整个字符串，用t保存当前字符串，count保存当前数字，碰到字母就添加到t中，碰到数字便循环读取并转换成正确的格式，当读取到‘[’时，将count入数字栈，将当前字符入字符栈，并将t清空，当读取到‘]’时，去数字栈顶元素k与字符栈顶元素s，t=s+k个t，直至栈为空结束，t即为所求。 Code：//beat 50% class Solution { public String decodeString(String s) { Stack&lt;Integer&gt; sNum=new Stack&lt;Integer&gt;(); Stack&lt;String&gt; sStr=new Stack&lt;String&gt;(); char[] chr=s.toCharArray(); String t=""; String count=""; for(int i=0;i&lt;chr.length;i++){ if(chr[i]&gt;='0' &amp;&amp; chr[i]&lt;='9'){ while(chr[i]!='['){ count+=chr[i++]; } sNum.push(Integer.parseInt(count)); count=""; } else if(chr[i]&lt;'0' || chr[i]&gt;'9' &amp;&amp;chr[i]!=']' &amp;&amp;chr[i]!='[') t+=chr[i]; if(chr[i]=='['){ sStr.push(t); t=""; } if(chr[i]==']'){ int k=1; if(!sNum.isEmpty()){ k=sNum.pop(); String top=sStr.pop(); for(int j=0;j&lt;k;j++) top+=t; t=top; } } } return t; } }]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 363】Max Sum of Rectangle No Larger Than K]]></title>
    <url>%2F2018%2F05%2F25%2F%5BLeetCode%20363%5D%20Max%20Sum%20of%20Rectangle%20No%20Larger%20Than%20K%20%2F</url>
    <content type="text"><![CDATA[[LeetCode 363] Max Sum of Rectangle No Larger Than KProblem description:Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Note:The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data. Example1:12345Given matrix = [ [1, 0, 1], [0, -2, 3]]k = 2 The answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2). Note: The rectangle inside the matrix must have an area &gt; 0. What if the number of rows is much larger than the number of columns? 问题描述:给定一个非空的二位矩阵和一个整数K，找到矩阵中子矩阵和最大并且不超过k的最大值。 示例1:12345给定矩阵 matrix = [ [1, 0, 1], [0, -2, 3]]k = 2 答案是2，因为矩形[[0, 1], [-2, 3]]和是2并且2 是不超过k（k=2）的最大值 。 Solution1: 这道题用纯暴力只能过95%左右，后面几个用例都会超时，所以在暴力的基础上稍微改进一下即可通过。（但不是最优解，复杂度为O(N2M2)） 用一个新矩阵保存计算值，每个值表示从点（0,0）到（i,j）的和，则计算（x1,y1）到（x2,y2）的值有以下四种情况： x1-1&lt;0 &amp;&amp; y1-1&lt;0: 说明（x1,y1）即为（0,0）点，直接返回存储矩阵中s[x2][y2]的值 x1-1&gt;=0 &amp;&amp; y1-1&lt;0: 说明y1=0， 1234561 2 3 4-------5 6 7 80 1 2 9-------计算从（1,0）到（3，3）的值 则返回s[x2][y2]-s[x1-1][y2] x1-1=0: 说明x1=0， 123451|2 3 4|5|6 7 8|0|1 2 9|计算从（0,1）到（3，3）的值 则返回s[x2][y2]-s[x2][y1-1] x1-1&gt;=0 &amp;&amp; y1-1&gt;=0: 123451 2 3 4 -------5|6 7 8|0|1 2 9| ------- 则返回s[x2][y2]-(s[x1-1][y2]+s[x2][y1-1]-s[x1-1][y1-1]) 遍历子矩阵用四层循环即可解决。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; public int maxSumSubmatrix(int[][] matrix, int k) &#123; int max=0; int row=matrix.length; int col=matrix[0].length; int [][]store=new int[row][col]; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; store[i][j]=sum(matrix,0,0,i,j); &#125; &#125; boolean flag=true; for(int x=0;x&lt;row;x++)&#123; for(int y=0;y&lt;col;y++)&#123; for(int i=x;i&lt;row;i++)&#123; for(int j=y;j&lt;col;j++)&#123; int t=sSum(store,x,y,i,j); if(t==k) return t; if(flag &amp;&amp; t&lt;k)&#123; max=t; flag=false; &#125; if(t&lt;k)&#123; max=Math.max(t,max); &#125; &#125; &#125; &#125; &#125; return max; &#125; public int sSum(int [][]s,int x1,int y1,int x2,int y2 )&#123; if(x1-1&lt;0 &amp;&amp; y1-1&lt;0) return s[x2][y2]; if(x1-1&gt;=0 &amp;&amp; y1-1&lt;0) return s[x2][y2]-s[x1-1][y2]; if(x1-1&lt;0 &amp;&amp; y1-1&gt;=0) return s[x2][y2]-s[x2][y1-1]; else&#123; return s[x2][y2]-(s[x1-1][y2]+s[x2][y1-1]-s[x1-1][y1-1]); &#125; &#125; public int sum(int [][]matrix,int x1,int y1,int x2,int y2)&#123; int res=0; for(int i=x1;i&lt;=x2;i++)&#123; for(int j=y1;j&lt;=y2;j++)&#123; res+=matrix[i][j]; &#125; &#125; return res; &#125;&#125; Solution2:动态递归解法（学习后补充）首先使用动态规划解法，这道题目可以拆分成两道题。第一点是求矩阵子矩阵最大和的动态规划思想，参考视频链接。 具体思想就是，按列扫描累加每一列然后求最大值，这样就转换为一维数组子数组求最大和的问题，这是一个简单的动态规划，dp[i]=max(dp[i-1],array[i]); 第二点就是一维数组子数组最大和有可能大于给定的k，所以问题转换为求一维数组子数组和不大于k的最大值： 通过累加和可以求得任意区间的和，例如，cum数组为累加和数组，cum[i]表示从cum[0]到cum[i]的和，则区间（i,j）的和可表示为cum[j]-cum[i-1]; 这里还要借助TreeSet因为treeset中ceiling方法可以求出大于或等于给定的元素的最小元素，也就是说我们在累加过程中去比较max和set.ceiling(sum-k)的大小即可，由于treeset查询这一步时间复杂度是O(logn),所以总的时间复杂度是O(N2*M*log(M)),如果列数远远大于行数，可以按照行扫描。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int maxSumSubmatrix(int[][] matrix, int k) &#123; int rowSize=matrix.length; int colSize=matrix[0].length; int maxSum=Integer.MIN_VALUE; int currentSum=0; // int maxLeft=0; // int maxRight=0; // int maxUp=0; // int maxDown=0; int []rowArray=new int[rowSize]; for(int left=0;left&lt;colSize;left++)&#123; for(int right=left;right&lt;colSize;right++)&#123; for(int i=0;i&lt;rowSize;i++)&#123; rowArray[i]+=matrix[i][right]; &#125; currentSum=maxSubArray(rowArray,k); if(currentSum==k) return k; if(currentSum&lt;k) maxSum=Math.max(currentSum,maxSum); &#125; for(int i=0;i&lt;rowSize;i++)&#123; rowArray[i]=0; &#125; &#125; return maxSum; &#125; public int maxSubArray(int []a,int k)&#123; TreeSet&lt;Integer&gt; set=new TreeSet&lt;Integer&gt;(); int sum=0; int max=Integer.MIN_VALUE; set.add(0); for(int i=0;i&lt;a.length;i++)&#123; sum+=a[i]; Integer v=set.ceiling(sum-k);//返回大于或等于给定的元素的最小元素，或null if(v!=null)&#123; max=Math.max(sum-v,max); &#125; set.add(sum); &#125; return max; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 393】UTF-8 Validation UTF-8 编码验证]]></title>
    <url>%2F2018%2F05%2F25%2F%5BLeetCode%20393%5DUTF-8%20Validation%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[[LeetCode 393]UTF-8 Validation UTF-8 编码验证Problem description:A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules: For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one’s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.This is how the UTF-8 encoding would work: 1234567Char. number range | UTF-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx Given an array of integers representing the data, return whether it is a valid utf-8 encoding. Note:The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data. Example1:1234data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.Return true.It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character. Example2:123456data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.Return false.The first 3 bits are all one&apos;s and the 4th bit is 0 means it is a 3-bytes character.The next byte is a continuation byte which starts with 10 and that&apos;s correct.But the second continuation byte does not start with 10, so it is invalid. 问题描述:UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则： 对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。 对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 这是 UTF-8 编码的工作方式： 1234567Char. number range | UTF-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。 说明：输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。 示例1:1234data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.返回 true 。这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。 示例2:123456data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.返回 false 。前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。下一个字节是开头为 10 的延续字节，这是正确的。但第二个延续字节不以 10 开头，所以是不符合规则的。 Solution: 一开始我理解出现错误认为只有一个utf-8编码让你判断，其实是判断一组连续的编码序列，也就是若干个utf-8序列。 不用位运算的方法，也就是将每个数据通过Integer.toBinaryString(data).toCharArray来判断。 更简洁的做法是直接通过位运算来记录1的位数，过程如下: data&gt;&gt;5==0b110 右移5位如果是0b110说明有2个字节，还有1个字节需要额外判断（ 或者data &amp; 0b11000000==0b11000000,与上述功能一致 ） data&gt;&gt;4==0b1110 右移4位如果是0b1110说明有3个字节，还有2个字节需要额外判断 data&gt;&gt;3==0b11110 右移3位如果是0b110说明有4个字节，还有3个字节需要额外判断 data&gt;&gt;7=0b1表示字符为10000000情况直接返回false 如果bitSize==1，表示当前为utf—8编码的第一个字符，做以上判断 如果bitSize!=1，表示当前正在判断10开头的字符，如果data[i]&gt;&gt;6!=0b10，直接返回false Code:123456789101112131415161718192021class Solution &#123; public boolean validUtf8(int[] data) &#123; int bitSize=1; for(int i=0;i&lt;data.length;i++)&#123; if(bitSize==1)&#123; if(data[i]&gt;&gt;5==0b110) bitSize=2; else if(data[i]&gt;&gt;4==0b1110) bitSize=3; else if(data[i]&gt;&gt;3==0b11110) bitSize=4; else if(data[i]&gt;&gt;7==0b1) return false;//10000000情况 &#125;else&#123; if(data[i]&gt;&gt;6!=0b10) return false; bitSize--; &#125; &#125; return bitSize==1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 70】Climbing Stairs 爬楼梯]]></title>
    <url>%2F2018%2F05%2F25%2F%5BLeetCode%2070%5DClimbing%20Stairs%20%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[[LeetCode 70]Climbing Stairs 爬楼梯Problem description:You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example:12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps 问题描述:假设你正在爬楼梯。需要 n 步你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 说明：给定 n 是一个正整数。 示例:12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 步 + 1 步2. 2 步 Solution:通过归纳可知符合斐波那契数列。 Code:12345678910111213141516171819class Solution &#123; public int climbStairs(int n) &#123; if(n==1) return 1; if(n==2) return 2; int f1=1; int f2=2; int sum=0; for(int i=2;i&lt;n;i++)&#123; sum=f1+f2; f1=f2; f2=sum; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 01】 Two Sum 两数之和]]></title>
    <url>%2F2018%2F05%2F24%2F%5BLeetCode%2001%5DTwo%20Sum%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[LeetCode 01]Two Sum 两数之和Problem decription:Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 题目描述：给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例:123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] Solution： 排序数组，用两个头尾指针遍历即可，排序复杂度为O(nlogn),空间复杂度为O(1)； 利用map，以&lt;值,数组下标&gt;方式储存，再遍历数组即可； 这里采用第二种解法，要注意考虑数组中包含重复值的情况，在加入map的过程中要做判断； Code：123456789101112131415161718192021222324252627import java.util.HashMap;class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; h=new HashMap&lt;Integer,Integer&gt;(); int []result=new int[2]; boolean flag=true; for(int i=0;i&lt;nums.length;i++)&#123; if(h.containsKey(nums[i]) &amp;&amp; 2*nums[i]==target)&#123; result[0]=h.get(nums[i]); result[1]=i; flag=false;// 如果在加入时的重复值即为结果，则后面无需执行 &#125; h.put(nums[i],i); &#125; for(int j=0;j&lt;nums.length;j++)&#123; if(h.containsKey(target-nums[j]) &amp;&amp; target-nums[j]!=nums[j] &amp;&amp; flag)&#123; result[0]=j; result[1]=h.get(target-nums[j]); break; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 48】Rotate Image 旋转图像]]></title>
    <url>%2F2018%2F05%2F24%2F%5BLeetCode%2048%5DRotate%20Image%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[[LeetCode 48]Rotate Image 旋转图像Problem description:You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note:You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1:12345678910111213Given input matrix =[ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2:123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]],rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 问题描述:给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明:你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例1:12345678910111213给定 matrix =[ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例2:123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]],原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] Solution:将矩阵沿着主对角线翻转一次，再沿着对称线旋转一次即可。 Code:123456789101112131415161718192021222324252627class Solution &#123; public void rotate(int[][] matrix) &#123; int n=matrix[0].length; int num=1; //沿着主对角线翻转 for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;num;j++)&#123; int temp=matrix[i][j]; matrix[i][j]=matrix[j][i]; matrix[j][i]=temp; &#125; num++; &#125; //沿着对称轴线翻转 for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n/2;j++)&#123; int temp=matrix[i][j]; matrix[i][j]=matrix[i][n-j-1]; matrix[i][n-j-1]=temp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 78】Subsets 子集]]></title>
    <url>%2F2018%2F05%2F24%2F%5BLeetCode%2078%5DSubsets%20%E5%AD%90%E9%9B%86%2F</url>
    <content type="text"><![CDATA[[LeetCode 78]Subsets 子集Problem description:Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example:123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 问题描述:给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] Solution:Solution 1: 一个集合有n个元素，则其有2n的子集。 列出从0到2n-1的所有二进制，0表示不取对应元素，1表示取对应元素，即可得出所有子集。 123456789 1 2 3 Subset0 0 0 0 []1 0 0 1 32 0 1 0 23 0 1 1 234 1 0 0 15 1 0 1 136 1 1 0 127 1 1 1 123 Code:1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); int count=pow(2,nums.length); for(int i=0;i&lt;count;i++)&#123; char []bit=Integer.toBinaryString(i).toCharArray(); ArrayList&lt;Integer&gt; temp=new ArrayList&lt;Integer&gt;(); //从数组最后一位开始判断 for(int j=bit.length-1,k=nums.length-1;j&gt;=0;j--,k--)&#123; if(bit[j]=='1') temp.add(nums[k]); &#125; Collections.sort(temp); res.add(temp); temp=new ArrayList&lt;Integer&gt;(); &#125; return res; &#125; public int pow(int i,int n)&#123; int res=1; for(int k=0;k&lt;n;k++)&#123; res*=i; &#125; return res; &#125;&#125; Solution 2：深度优先算法，由于原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况，所以可以构造一棵二叉树，左子树表示选择该元素，右子树表示不选择，最终的叶节点就是所有子集合，树的结构如下： 12345678910 [] / \ / \ / \ [1] [] / \ / \ / \ / \ [1 2] [1] [2] [] / \ / \ / \ / \[1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] [] Code:123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; temp=new ArrayList&lt;Integer&gt;(); getSubList(nums,res,temp,0); return res; &#125; public void getSubList(int []nums,List&lt;List&lt;Integer&gt;&gt; res,ArrayList&lt;Integer&gt; temp,int pos)&#123; res.add(new ArrayList(temp));//注意要new一个ArrayList对象 for(int i=pos;i&lt;nums.length;i++)&#123; temp.add(nums[i]);//选择元素nums[i] getSubList(nums,res,temp,i+1);//下一个元素 temp.remove(temp.size()-1);//不选择nums[i] &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基本语法]]></title>
    <url>%2F2018%2F05%2F22%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[为了顺畅的在github pages上书写自己的blog，需要学习一些基本的MarkDown语法。 常用语法规则标题总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。快捷键：command + 1/2/3/4/5/6 换行只需在行末加两个空格键和一个回车键即可换行。快捷键：control + 回车键 文本样式123456加粗 - 快捷键：command + B 斜体 - 快捷键：command + I 删除线 - 快捷键：command + U 底纹 - 快捷键：command + K 下划线 - html：&lt;u&gt;text&lt;/u&gt;分割线 - 用*** 加粗 : hello* 斜体 * :hello~~ 删除线 ~~ :hello` 底纹 ` :hello分割线： 列表列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 无序列表 a b c 有序列表 a b c 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可 this is a quote 图片与链接图片为：![]() 链接为：[]() 在线插入：插入图片的地址需要图床，这里推荐围脖图床修复计划，生成URL 本地插入：![](本地路径) 插入图片 代码块使用三个`包裹代码即可 ,注意后面不要跟空格，hexo在生成网页时代码块之间匹配会出现问题 123var a = "hello world";var b = "hello world";]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github pages + hexo搭建博客]]></title>
    <url>%2F2018%2F05%2F22%2F%E4%BD%BF%E7%94%A8github%20pages%20%2B%20hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 目前比较热门的两种方式就是使用静态博客框架 jekyll 或者 hexo，相对于jekyll，hexo主题丰富，第三方插件优秀，配置简单，最主要的一点，hexo的开发文档阅读感受较jekyll来说更舒服。 一.环境搭建 官方文档非常详细 hexo documents 这里以MacOs为例 github账号注册地址 安装Node.js cURL:$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget:$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后重启终端：$ nvm install stable 这里推荐下载安装程序来安装 安装git$ brew install git 安装 Hexo$ npm install -g hexo-cli 二.建站123$ hexo init &lt;folderName&gt;$ cd &lt;folderName&gt;$ npm install 安装完成后文件目录结构如下： 12345678├── \_config.yml├── package.json├── scaffolds├── source| ├── \_drafts| └── \_posts└── themes 你可以在_config.yml中配置大部分网站设置。 其他一些Hexo常用命令： 1234567hexo n # 新建文章，在\source\_posts文件夹里hexo new page # 新建页面，比如想在导航栏新增一个“关于我”的页面hexo clean # 清除本地的数据库和生成的public文件夹hexo g # 生成博客文件hexo s # 运行在本地浏览器，可当预览使用hexo d # 部署博客到Github等 三.创建Repo 新建一个repo，注意名称一定是your_username.github.io这样的格式。 进入刚新建的仓库，点击Setting，一直拖到最下面，选择Automatic Page Generator，随便选个主题然后发布即可。 在站点_config.yml文件中任意位置添加以下代码段： 12345deploy: type: git # 填上你自己的仓库名，注意后面有`.git` repository: git@github.com:your_username/your_username.github.io.git branch: master 注意每个：后面都要跟一个空格！ 安装部署所需：$ npm install hexo-deployer-git --save 四.主题 创建 Hexo 主题非常容易，您只要在 themes 文件夹内，新增一个任意名称的文件夹，并修改 _config.yml 内的 theme 设定，即可切换主题。一个主题可能会有以下的结构： 123456.├── \_config.yml(配置是无需重启服务器会自动更新)├── languages├── layout├── scripts└── source 这里推荐使用最多的nexT 主题 五.新建页面新建分类页面：hexo new page categories 打开../source/categories/index.md 编辑相对应的type 123456---title: 分类date: 2018-05-21 22:00:35type: &quot;categories&quot;comments: false--- 在站点_config.yml中更改menu下代码，如果没有添加 categories: /categories/ 新建导航默认导航栏只有首页、归档、标签、分类四项。如果想增加其他如C++、随笔等。需要打开\themes\next_config.yml找到如下 123456789101112#When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / categories: /categories tags: /tags archives: /archives #这里是新增的，Coding是一级目录，C是二级目录，同理随笔是一级目录 c++: /categories/Coding/C/ python: /categories/Coding/Python/ essay: /categories/随笔/ #注意这里没有/categories about: /about that‘s all！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
</search>
