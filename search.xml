<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>【Leetcode80】Largest Rectangle in Histogram  最大面积覆盖的矩阵</title>
      <link href="/2018/09/27/%5BLeetcode85%5D%20Largest%20Rectangle%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
      <url>/2018/09/27/%5BLeetcode85%5D%20Largest%20Rectangle%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
      <content type="html"><![CDATA[<h1 id="Leetcode85-Largest-Rectangle-最大矩形"><a href="#Leetcode85-Largest-Rectangle-最大矩形" class="headerlink" title="[Leetcode85] Largest Rectangle 最大矩形"></a>[Leetcode85] Largest Rectangle 最大矩形</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</span></span><br><span class="line"><span class="comment"> * 示例:</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * ['1','0','1','0','0'],</span></span><br><span class="line"><span class="comment"> * ['1','0','1','1','1'],</span></span><br><span class="line"><span class="comment"> * ['1','1','1','1','1'],</span></span><br><span class="line"><span class="comment"> * ['1','0','0','1','0']</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * 输出: 6</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将矩阵转换成一每一行为底的柱形图，以leetcode84方法求解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode85</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span> <span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].length, row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] numOfOne = <span class="keyword">new</span> <span class="keyword">int</span>[row][column];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[column];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>)</span><br><span class="line">                    numOfOne[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    numOfOne[i][j] = i &gt; <span class="number">0</span> ? numOfOne[i - <span class="number">1</span>][j] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                heights[j] = numOfOne[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(largestRectangleArea(heights), max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span> <span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = heights[i];</span><br><span class="line">            <span class="keyword">int</span> l = i, r = i;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; heights[l] &gt;= index)</span><br><span class="line">                --l;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; heights.length &amp;&amp; heights[r] &gt;= index)</span><br><span class="line">                ++r;</span><br><span class="line">            <span class="keyword">int</span> area = heights[i] * (r - l + <span class="number">1</span> - <span class="number">2</span>);</span><br><span class="line">            max = Math.max(area, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] nums = <span class="keyword">new</span> <span class="keyword">char</span>[][]&#123;</span><br><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'0'</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> leetcode85().maximalRectangle(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Hard </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Leetcode80】Remove Duplicates from Sorted Array II  删除数组中的重复项II</title>
      <link href="/2018/09/27/%5BLeetcode80%5D%20Remove%20Duplicates%20from%20Sorted%20Array%20II%20%20%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/"/>
      <url>/2018/09/27/%5BLeetcode80%5D%20Remove%20Duplicates%20from%20Sorted%20Array%20II%20%20%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/</url>
      <content type="html"><![CDATA[<h1 id="Leetcode80-Remove-Duplicates-from-Sorted-Array-II-删除数组中的重复项II"><a href="#Leetcode80-Remove-Duplicates-from-Sorted-Array-II-删除数组中的重复项II" class="headerlink" title="[Leetcode80] Remove Duplicates from Sorted Array II  删除数组中的重复项II"></a>[Leetcode80] Remove Duplicates from Sorted Array II  删除数组中的重复项II</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</span></span><br><span class="line"><span class="comment"> * 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span></span><br><span class="line"><span class="comment"> * 示例 1:</span></span><br><span class="line"><span class="comment"> * 给定 nums = [1,1,1,2,2,3],</span></span><br><span class="line"><span class="comment"> * 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</span></span><br><span class="line"><span class="comment"> * 你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 注意是排好序的數組，所以比较前两个就好</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[index - <span class="number">2</span>]) &#123;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> leetcode80().removeDuplicates(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Medium </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>归并排序</title>
      <link href="/2018/09/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/09/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sort左边，sort右边，归并</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= h)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> left = l, right = h;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(nums, left, mid);</span><br><span class="line">        MergeSort(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        Merge(nums, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *左边l-m，右边m+1 - h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newNums[] = <span class="keyword">new</span> <span class="keyword">int</span>[h - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = l, j = m + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= h) &#123;</span><br><span class="line">            newNums[k++] = nums[i] &lt; nums[j] ? nums[i++] : nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m)</span><br><span class="line">            newNums[k++] = nums[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= h)</span><br><span class="line">            newNums[k++] = nums[j++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; newNums.length; p++) &#123;</span><br><span class="line">            nums[p + l] = newNums[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []nums = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        MergeSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t:nums) &#123;</span><br><span class="line">            System.out.print(t+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>堆排序</title>
      <link href="/2018/09/27/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/09/27/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        buildHeap(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">            maxHeapfy(nums,<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建堆，从下往上调整，从(n-1)/2-0，只有这些节点有子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ((nums.length - <span class="number">1</span>) - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapfy(nums,i,nums.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//length排序时用来限定排好的位数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapfy</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = index;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">2</span> * max + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = <span class="number">2</span> * max + <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//父节点、左孩子、右孩子选出最大</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; length &amp;&amp; nums[left] &gt; nums[max])</span><br><span class="line">                max = left;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; length &amp;&amp; nums[right] &gt; nums[max])</span><br><span class="line">                max = right;</span><br><span class="line">            <span class="comment">//交换并递归调整</span></span><br><span class="line">            <span class="keyword">if</span> (max != index) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[index];</span><br><span class="line">                nums[index] = nums[max];</span><br><span class="line">                nums[max] = temp;</span><br><span class="line">                index = max;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []nums = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        HeapSort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t:nums) &#123;</span><br><span class="line">            System.out.print(t+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Leetcode46】 Permutation 全排列</title>
      <link href="/2018/09/27/%5BLeetcode46%5D%20Permutation%20%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2018/09/27/%5BLeetcode46%5D%20Permutation%20%E5%85%A8%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="Leetcode46-Permutation-全排列"><a href="#Leetcode46-Permutation-全排列" class="headerlink" title="[Leetcode46] Permutation 全排列"></a>[Leetcode46] Permutation 全排列</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><p><code>`</code>java<br>/**</p><ul><li><p>全排列<br>*/<br>public class leetcode46 {<br> public List&lt;List<integer>&gt; permute (int[] nums) {</integer></p><pre><code>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();helper(res, nums, 0);return res;</code></pre><p> }</p><p> private void helper (List&lt;List<integer>&gt; res, int[] nums, int pos) {</integer></p><pre><code>if (pos == nums.length) {    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    for (int t : nums) {        list.add(t);    }    res.add(list);}for (int i = pos; i &lt; nums.length; i++) {    swap(nums, pos, i);    helper(res, nums, pos + 1);    swap(nums, pos, i);}</code></pre><p> }</p><p> private void swap (int[] nums, int i, int j) {</p><pre><code>int temp = nums[i];nums[i] = nums[j];nums[j] = temp;</code></pre><p> }<br>}</p></li></ul><p><code>`</code>**</p>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Medium </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Leetcode42】Trapping Rain Water 接雨水</title>
      <link href="/2018/09/27/%5BLeetcode42%5D%20Trapping%20Rain%20Water%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2018/09/27/%5BLeetcode42%5D%20Trapping%20Rain%20Water%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      <content type="html"><![CDATA[<h1 id="Leetcode42-Trapping-Rain-Water-接雨水"><a href="#Leetcode42-Trapping-Rain-Water-接雨水" class="headerlink" title="[Leetcode42] Trapping Rain Water 接雨水"></a>[Leetcode42] Trapping Rain Water 接雨水</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span></span><br><span class="line"><span class="comment"> * 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</span></span><br><span class="line"><span class="comment"> * 示例:</span></span><br><span class="line"><span class="comment"> * 输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span></span><br><span class="line"><span class="comment"> * 输出: 6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode42</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span> <span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxHeight = <span class="number">0</span>, maxLeft = <span class="number">0</span>, maxRight = <span class="number">0</span>, maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用最长的高度分割两侧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; ++i) &#123;</span><br><span class="line">            maxHeight = Math.max(maxHeight, height[i]);</span><br><span class="line">            maxIndex = maxHeight == height[i] ? i : maxIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左边计算</span></span><br><span class="line">        maxLeft = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxIndex; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxLeft &gt; height[i])</span><br><span class="line">                res += maxLeft - height[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                maxLeft = height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右边计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length - <span class="number">1</span>; i &gt;= maxIndex; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxRight &gt; height[i])</span><br><span class="line">                res += maxRight - height[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                maxRight = height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Hard </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Leetcode336】Palindrome Pairs  回文对</title>
      <link href="/2018/09/27/%5BLeetcode336%5D%20Palindrome%20Pairs%20%20%E5%9B%9E%E6%96%87%E5%AF%B9/"/>
      <url>/2018/09/27/%5BLeetcode336%5D%20Palindrome%20Pairs%20%20%E5%9B%9E%E6%96%87%E5%AF%B9/</url>
      <content type="html"><![CDATA[<h1 id="Leetcode336-Palindrome-Pairs-回文对"><a href="#Leetcode336-Palindrome-Pairs-回文对" class="headerlink" title="[Leetcode336] Palindrome Pairs  回文对"></a>[Leetcode336] Palindrome Pairs  回文对</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一组唯一的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。</span></span><br><span class="line"><span class="comment"> * 示例 1:</span></span><br><span class="line"><span class="comment"> * 输入: ["abcd","dcba","lls","s","sssll"]</span></span><br><span class="line"><span class="comment"> * 输出: [[0,1],[1,0],[3,2],[2,4]]</span></span><br><span class="line"><span class="comment"> * 解释: 可拼接成的回文串为 ["dcbaabcd","abcddcba","slls","llssssll"]</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> * 输入: ["bat","tab","cat"]</span></span><br><span class="line"><span class="comment"> * 输出: [[0,1],[1,0]]</span></span><br><span class="line"><span class="comment"> * 解释: 可拼接成的回文串为 ["battab","tabbat"]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 1、将字符串反转后和字符串下标放入map中</span></span><br><span class="line"><span class="comment"> * 2、遍历words数组，对每个字符串遍历即str = ls + rs</span></span><br><span class="line"><span class="comment"> * 3、如果ls是回文串，判断rs是否在map中，如果在，则   sr+ls+rs(map中存的是sr的反转序列)，则（map中的下标，当前字符串下标）为一组结果</span></span><br><span class="line"><span class="comment"> * 4、如果rs是回文串，判断ls是否在map中，如果在，则 ls+rs+sl 是反转序列，则（当前字符串下标，map中的下标）为一组结果</span></span><br><span class="line"><span class="comment"> * 5、对于空字符串""单独判断，如果words中字符串是回文串，则将下标保存到list，（空字符串下标，list中保存的下标）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode336</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TLE超时</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; palindromePairs (String[] words) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">                StringBuilder s1 = <span class="keyword">new</span> StringBuilder().append(words[i]).append(words[j]);</span><br><span class="line">                StringBuilder s2 = <span class="keyword">new</span> StringBuilder().append(words[j]).append(words[i]);</span><br><span class="line">                <span class="keyword">if</span> (s1.toString().equals(s1.reverse().toString())) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    list.add(j);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s2.toString().equals(s2.reverse().toString())) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(j);</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//AC</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; solution (String[] words) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> StringBuilder(words[i]).reverse().toString(), i);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        List&lt;Integer&gt; palindromeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">                String ls = words[i].substring(<span class="number">0</span>, j);</span><br><span class="line">                String rs = words[i].substring(j, words[i].length());</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; isPalindrome(rs))</span><br><span class="line">                    palindromeList.add(i);</span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(ls) &amp;&amp; map.containsKey(rs)) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">if</span> (map.get(rs) != i) &#123;</span><br><span class="line">                        list.add(map.get(rs));</span><br><span class="line">                        list.add(i);</span><br><span class="line">                        res.add(list);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(rs) &amp;&amp; map.containsKey(ls)) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">if</span> (map.get(ls) != i) &#123;</span><br><span class="line">                        list.add(i);</span><br><span class="line">                        list.add(map.get(ls));</span><br><span class="line">                        res.add(list);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理空字符串</span></span><br><span class="line">            <span class="keyword">if</span> (words[i].equals(<span class="string">""</span>))</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer t : palindromeList) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(map.get(<span class="string">""</span>));</span><br><span class="line">                list.add(t);</span><br><span class="line">                res.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.equals(<span class="keyword">new</span> StringBuilder(str).reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] words = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">""</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> leetcode336().solution(words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Hard </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Leetcode17】Letter Combinations of a Phone Number 电话号码的字母组合</title>
      <link href="/2018/09/27/%5BLeetcode17%5D%20Letter%20Combinations%20of%20a%20Phone%20Number%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
      <url>/2018/09/27/%5BLeetcode17%5D%20Letter%20Combinations%20of%20a%20Phone%20Number%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
      <content type="html"><![CDATA[<h1 id="Leetcode17-Letter-Combinations-of-a-Phone-Number-电话号码的字母组合"><a href="#Leetcode17-Letter-Combinations-of-a-Phone-Number-电话号码的字母组合" class="headerlink" title="[Leetcode17] Letter Combinations of a Phone Number 电话号码的字母组合"></a>[Leetcode17] Letter Combinations of a Phone Number 电话号码的字母组合</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</span></span><br><span class="line"><span class="comment"> * 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</span></span><br><span class="line"><span class="comment"> * 可以任意选择答案输出的顺序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dfs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode17</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span> <span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        map.put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        map.put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">        map.put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        map.put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        map.put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">        map.put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        map.put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        map.put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res, <span class="keyword">new</span> String(), digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span> <span class="params">(List&lt;String&gt; res, String bag, String digits, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == digits.length()) &#123;</span><br><span class="line">            res.add(bag);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> digit = digits.charAt(pos);</span><br><span class="line">        String letter = map.get(digit);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letter.length(); i++) &#123;</span><br><span class="line">            helper(res, bag + letter.charAt(i), digits, pos + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> leetcode17().letterCombinations(<span class="string">"23"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Medium </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Leetcode80】Largest Rectangle in Histogram  最大面积覆盖的矩阵</title>
      <link href="/2018/09/27/%5BLeetcode84%5D%20Largest%20Rectangle%20in%20Histogram%20%20%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E8%A6%86%E7%9B%96%E7%9A%84%E7%9F%A9%E9%98%B5/"/>
      <url>/2018/09/27/%5BLeetcode84%5D%20Largest%20Rectangle%20in%20Histogram%20%20%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E8%A6%86%E7%9B%96%E7%9A%84%E7%9F%A9%E9%98%B5/</url>
      <content type="html"><![CDATA[<h1 id="Leetcode84-Largest-Rectangle-in-Histogram-最大面积覆盖的矩阵"><a href="#Leetcode84-Largest-Rectangle-in-Histogram-最大面积覆盖的矩阵" class="headerlink" title="[Leetcode84] Largest Rectangle in Histogram  最大面积覆盖的矩阵"></a>[Leetcode84] Largest Rectangle in Histogram  最大面积覆盖的矩阵</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</span></span><br><span class="line"><span class="comment"> * 求在该柱状图中，能够勾勒出来的矩形的最大面积。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从中间向两端发散计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode84</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span> <span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = heights[i];</span><br><span class="line">            <span class="keyword">int</span> l = i, r = i;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; heights[l] &gt;= index)</span><br><span class="line">                --l;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; heights.length &amp;&amp; heights[r] &gt;= index)</span><br><span class="line">                ++r;</span><br><span class="line">            <span class="keyword">int</span> area = heights[i] * (r - l + <span class="number">1</span>-<span class="number">2</span>);</span><br><span class="line">            max = Math.max(area, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> leetcode84().largestRectangleArea(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Hard </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 79】 Word Search 单词搜素</title>
      <link href="/2018/09/13/%5BLeetCode%2079%5D%20Word%20Search%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A0/"/>
      <url>/2018/09/13/%5BLeetCode%2079%5D%20Word%20Search%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A0/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-79-Word-Search-单词搜素"><a href="#LeetCode-79-Word-Search-单词搜素" class="headerlink" title="[LeetCode 79] Word Search 单词搜素"></a>[LeetCode 79] Word Search 单词搜素</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个二维网格和一个单词，找出该单词是否存在于网格中。</span></span><br><span class="line"><span class="comment"> * 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode79</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span> <span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (helper(board, word, i, j, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span> <span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == word.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (word.charAt(pos) != board[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">        <span class="comment">//表示已经访问不能再次访问</span></span><br><span class="line">        board[i][j] = <span class="string">'*'</span>;</span><br><span class="line">        res = helper(board, word, i - <span class="number">1</span>, j, pos + <span class="number">1</span>)</span><br><span class="line">                || helper(board, word, i + <span class="number">1</span>, j, pos + <span class="number">1</span>)</span><br><span class="line">                || helper(board, word, i, j - <span class="number">1</span>, pos + <span class="number">1</span>)</span><br><span class="line">                || helper(board, word, i, j + <span class="number">1</span>, pos + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//恢复未访问状态</span></span><br><span class="line">        board[i][j] = temp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> [][]a= <span class="keyword">new</span> <span class="keyword">char</span> [][]&#123;&#123;<span class="string">'C'</span>,<span class="string">'A'</span>,<span class="string">'A'</span>&#125;,</span><br><span class="line">                                  &#123;<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'A'</span>&#125;,</span><br><span class="line">                                  &#123;<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">new</span> leetcode79().exist(a,<span class="string">"AAB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 93】Restore IP Addresses 恢复IP地址</title>
      <link href="/2018/09/13/%5BLeetCode%2093%5D%20Restore%20IP%20Addresses%20%E6%81%A2%E5%A4%8DIP%E5%9C%B0%E5%9D%80/"/>
      <url>/2018/09/13/%5BLeetCode%2093%5D%20Restore%20IP%20Addresses%20%E6%81%A2%E5%A4%8DIP%E5%9C%B0%E5%9D%80/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-93-Restore-IP-Addresses-恢复IP地址"><a href="#LeetCode-93-Restore-IP-Addresses-恢复IP地址" class="headerlink" title="[LeetCode 93] Restore IP Addresses 恢复IP地址"></a>[LeetCode 93] Restore IP Addresses 恢复IP地址</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</span></span><br><span class="line"><span class="comment"> * 示例:</span></span><br><span class="line"><span class="comment"> * 输入: "25525511135"</span></span><br><span class="line"><span class="comment"> * 输出: ["255.255.11.135", "255.255.111.35"]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode93</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">4</span> || s.length()&gt;<span class="number">12</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        helper(res, s, <span class="keyword">new</span> String(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span> <span class="params">(List&lt;String&gt; res, String s, String str, <span class="keyword">int</span> pos, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">//插入四个即为终止条件</span></span><br><span class="line">            String seg = s.substring(pos);</span><br><span class="line">            <span class="keyword">if</span> (isValid(seg)) &#123;</span><br><span class="line">                str = str + seg;</span><br><span class="line">                res.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有效位只能为3位以内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span> &amp;&amp; pos + i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//important</span></span><br><span class="line">            String seg = s.substring(pos, pos + i);</span><br><span class="line">            <span class="keyword">if</span> (isValid(seg)) &#123;</span><br><span class="line">                helper(res, s, str + seg + <span class="string">"."</span>, pos + i, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span> <span class="params">(String seg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(seg.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; seg.length()&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> ipNum = Integer.valueOf(seg);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= ipNum &amp;&amp; ipNum &lt;= <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> leetcode93().restoreIpAddresses(<span class="string">"010010"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 75】 Sort Colors 排序颜色</title>
      <link href="/2018/09/13/%5BLeetCode%2075%5D%20Sort%20Colors%20%E6%8E%92%E5%BA%8F%E9%A2%9C%E8%89%B2/"/>
      <url>/2018/09/13/%5BLeetCode%2075%5D%20Sort%20Colors%20%E6%8E%92%E5%BA%8F%E9%A2%9C%E8%89%B2/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-75-Sort-Colors-排序颜色"><a href="#LeetCode-75-Sort-Colors-排序颜色" class="headerlink" title="[LeetCode 75] Sort Colors 排序颜色"></a>[LeetCode 75] Sort Colors 排序颜色</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</span><br><span class="line"> * 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</span><br><span class="line"> * 注意:</span><br><span class="line"> * 不能使用代码库中的排序函数来解决这道题。</span><br><span class="line"> *</span><br><span class="line"> * 遇到0放到左边，2放到右边，1跳过</span><br><span class="line"> */</span><br><span class="line">public class leetcode75 &#123;</span><br><span class="line"></span><br><span class="line">    public void sortColors (int[] nums) &#123;</span><br><span class="line">        int pre = 0;</span><br><span class="line">        int post = nums.length - 1;</span><br><span class="line">        for (int i = 0; i &lt;= post; i++) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                int t = nums[pre];</span><br><span class="line">                nums[pre] = nums[i];</span><br><span class="line">                nums[i] = t;</span><br><span class="line">                ++pre;</span><br><span class="line">            &#125; else if (nums[i] == 2) &#123;</span><br><span class="line">                int t = nums[post];</span><br><span class="line">                nums[post] = nums[i];</span><br><span class="line">                nums[i] = t;</span><br><span class="line">                --i;</span><br><span class="line">                --post;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        new leetcode75().sortColors(new int[]&#123;1,2,2,1,1,0,0,2,0,0,1,0,0,1,0&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 73】Set Matrix Zeroes 矩阵置零</title>
      <link href="/2018/09/13/%5BLeetCode%2073%5DSet%20Matrix%20Zeroes%20%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
      <url>/2018/09/13/%5BLeetCode%2073%5DSet%20Matrix%20Zeroes%20%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><h1 id="LeetCode-73-Set-Matrix-Zeroes-矩阵置零"><a href="#LeetCode-73-Set-Matrix-Zeroes-矩阵置零" class="headerlink" title="[LeetCode 73]Set Matrix Zeroes 矩阵置零"></a>[LeetCode 73]Set Matrix Zeroes 矩阵置零</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 用第一行第一列记录每一行每一列的信息，用两个int记录第一行第一列的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode73</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span> <span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row0Flag = <span class="number">1</span>, colum0Flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) &#123;</span><br><span class="line">                row0Flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                colum0Flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.length; ++j) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row0Flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; ++i) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (colum0Flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KMP</title>
      <link href="/2018/09/13/KMP%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/13/KMP%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="KMP-字符串匹配算法"><a href="#KMP-字符串匹配算法" class="headerlink" title="KMP 字符串匹配算法"></a>KMP 字符串匹配算法</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span> <span class="params">(String target, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = getNextArray2(pattern);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; pattern.length() &amp;&amp; j &lt; target.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == -<span class="number">1</span> || pattern.charAt(i) == target.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/** 回退</span></span><br><span class="line"><span class="comment">                 * ABCDABD</span></span><br><span class="line"><span class="comment">                 * 如最后一位没有匹配到，则需回退到下标2</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                i = i - <span class="number">1</span> &gt; <span class="number">0</span> ? next[i - <span class="number">1</span>] : -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == pattern.length())</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算出的数组A表示以这一位位阶为的最长前后缀</span></span><br><span class="line"><span class="comment">     * 而next数组则为数组A右移一位，第一个值赋为-1</span></span><br><span class="line"><span class="comment">     * 如ABCDABD</span></span><br><span class="line"><span class="comment">     * getNextArray计算出来：0 0 0 0 1 2 0</span></span><br><span class="line"><span class="comment">     * 真正的next：-1 0 0 0 0 1 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextArray (String pattern) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pattern.length(); i++) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *    ABCABD</span></span><br><span class="line"><span class="comment">             *    判断D与C是否相等</span></span><br><span class="line"><span class="comment">             *    类似于动态规划</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(next[i - <span class="number">1</span>]) == pattern.charAt(i))</span><br><span class="line">                next[i] = next[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 不相等，递归next</span></span><br><span class="line"><span class="comment">                 * ABABCABABD</span></span><br><span class="line"><span class="comment">                 * D不等于C,递归next[C的下标 - 1]</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">int</span> j = next[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pattern.charAt(j) == pattern.charAt(i))</span><br><span class="line">                        next[i] = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        j = next[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; pattern.charAt(<span class="number">0</span>) == pattern.charAt(i))</span><br><span class="line">                    next[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    next[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接求next数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextArray2 (String pattern) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; pattern.length()-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || pattern.charAt(j) == pattern.charAt(i)) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">            KMP.kmp(<span class="string">"BBC_ABCDAB_ABCDABCDABDE"</span>, <span class="string">"ABABBCABB"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用LinkedHashMap实现LRU算法</title>
      <link href="/2018/09/13/%E5%88%A9%E7%94%A8LinkedHashMap%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/13/%E5%88%A9%E7%94%A8LinkedHashMap%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="利用LinkedHashMap实现LRU算法"><a href="#利用LinkedHashMap实现LRU算法" class="headerlink" title="利用LinkedHashMap实现LRU算法"></a>利用LinkedHashMap实现LRU算法</h1><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lruByLinkedHashMap</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;Integer, Integer&gt;(<span class="number">20</span>, (<span class="keyword">float</span>) <span class="number">0.75</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span> <span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            map.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        map.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"访问元素1后: "</span> + map.toString());</span><br><span class="line">        map.put(<span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(<span class="string">"添加元素11后: "</span> + map.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lruCacheByHand</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; buffer = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">10</span>, <span class="number">0.75f</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buffer.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer.toString());</span><br><span class="line">        getByHand(buffer,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"手动访问元素1后: "</span> + buffer.toString());</span><br><span class="line">        addByHand(buffer,<span class="number">11</span>);</span><br><span class="line">        System.out.println(<span class="string">"手动添加元素11后: "</span> + buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addByHand</span> <span class="params">(Map&lt;Integer, Integer&gt; buffer, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.size() &lt; <span class="number">10</span>)</span><br><span class="line">            buffer.put(num, num);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            buffer.remove(buffer.entrySet().iterator().next().getKey());</span><br><span class="line">            buffer.put(num, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getByHand</span> <span class="params">(Map&lt;Integer, Integer&gt; buffer, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.containsKey(num)) &#123;</span><br><span class="line">            Integer key = num;</span><br><span class="line">            Integer value = buffer.get(key);</span><br><span class="line">            buffer.remove(key);</span><br><span class="line">            buffer.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRU.lruByLinkedHashMap();</span><br><span class="line">        LRU.lruCacheByHand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2018/09/10/%E3%80%90LeetCode%2057%E3%80%91%20Insert%20Interval%20%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
      <url>/2018/09/10/%E3%80%90LeetCode%2057%E3%80%91%20Insert%20Interval%20%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
      <content type="html"><![CDATA[<hr><p>title: 【LeetCode 57】 Insert Interval 插入区间<br>tags: [算法,LeetCode,Hard]<br>categories: LeetCode</p><h2 id="date-2018-09-09"><a href="#date-2018-09-09" class="headerlink" title="date: 2018-09-09"></a>date: 2018-09-09</h2><p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给出一个无重叠的 ，按照区间起始端点排序的区间列表。</span></span><br><span class="line"><span class="comment"> * 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * copy 56，把要加入的区间放到集合中合并</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode57</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        Interval () &#123;</span><br><span class="line">            start = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Interval (<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">            start = s;</span><br><span class="line">            end = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span> <span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">        intervals.add(newInterval);</span><br><span class="line">        <span class="keyword">return</span> merge(intervals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span> <span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        Collections.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(Interval o1, Interval o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1.start, o2.start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            Interval left = intervals.get(i - <span class="number">1</span>);</span><br><span class="line">            Interval right = intervals.get(i);</span><br><span class="line">            Interval mergeInterval = <span class="keyword">new</span> Interval();</span><br><span class="line">            <span class="keyword">if</span> (right.start &lt;= left.end) &#123;</span><br><span class="line">                mergeInterval = <span class="keyword">new</span> Interval(left.start, Math.max(left.end, right.end));</span><br><span class="line">                intervals.set(i, mergeInterval);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                res.add(intervals.get(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(intervals.get(intervals.size() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>【LeetCode 63】Unique Paths II 不同路径II</title>
      <link href="/2018/09/10/%E3%80%90LeetCode%2063%E3%80%91Unique%20Paths%20II%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
      <url>/2018/09/10/%E3%80%90LeetCode%2063%E3%80%91Unique%20Paths%20II%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</span></span><br><span class="line"><span class="comment"> * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</span></span><br><span class="line"><span class="comment"> * 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</span></span><br><span class="line"><span class="comment"> * 网格中的障碍物和空位置分别用 1 和 0 来表示。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode63</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span> <span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i &gt; <span class="number">0</span> ? i - <span class="number">1</span> : <span class="number">0</span>][j &gt; <span class="number">0</span> ? j - <span class="number">1</span> : <span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(m)空间复杂度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *要注意的是因为有可能存在障碍物，所以i或j为0时不再是总为1了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePathWithObstacles2</span> <span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> ? <span class="number">0</span> : dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] != <span class="number">1</span>)</span><br><span class="line">                    dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        leetcode63.uniquePathWithObstacles2(<span class="keyword">new</span> <span class="keyword">int</span> [][]&#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">0</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 199】Binary Tree Right Side View 二叉树的右视图</title>
      <link href="/2018/09/10/%E3%80%90LeetCode%20199%E3%80%91Binary%20Tree%20Right%20Side%20View%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
      <url>/2018/09/10/%E3%80%90LeetCode%20199%E3%80%91Binary%20Tree%20Right%20Side%20View%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 层次遍历，输出每一行末尾节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode199</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">     * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">     * int val;</span></span><br><span class="line"><span class="comment">     * TreeNode left;</span></span><br><span class="line"><span class="comment">     * TreeNode right;</span></span><br><span class="line"><span class="comment">     * TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">rightSideView</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            res.add((((LinkedList&lt;TreeNode&gt;) queue).peekLast().val));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode r = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(r.left);</span><br><span class="line">                <span class="keyword">if</span> (r.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(r.right);</span><br><span class="line">            &#125;</span><br><span class="line">            size = queue.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 41】First Missing Positive 缺失的第一个正数</title>
      <link href="/2018/09/10/%E3%80%90LeetCode%2041%E3%80%91First%20Missing%20Positive%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
      <url>/2018/09/10/%E3%80%90LeetCode%2041%E3%80%91First%20Missing%20Positive%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</span></span><br><span class="line"><span class="comment"> * 输入: [1,2,0]</span></span><br><span class="line"><span class="comment"> * 输出: 3</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> * 输入: [3,4,-1,1]</span></span><br><span class="line"><span class="comment"> * 输出: 2</span></span><br><span class="line"><span class="comment"> * 示例 3:</span></span><br><span class="line"><span class="comment"> * 输入: [7,8,9,11,12]</span></span><br><span class="line"><span class="comment"> * 输出: 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 下标i存储i+1，若为负数或超出数组长度则位置不变</span></span><br><span class="line"><span class="comment"> * 找出第一个nums[i] != i+1即为所解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode41</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span> &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = t;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 106】Construct Binary Tree from Inorder and Postorder Traversal 从中序与后序遍历序列构造二叉树</title>
      <link href="/2018/09/10/%E3%80%90LeetCode%20106%E3%80%91Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/09/10/%E3%80%90LeetCode%20106%E3%80%91Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</span></span><br><span class="line"><span class="comment"> * 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</span></span><br><span class="line"><span class="comment"> * 必须原地修改，只允许使用额外常数空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 下一个全排列就是找到比当前数大的最小值，找到降序排列开始的位置，记为i，从i到n找到比nums[i-1]大的最小值与i-1交换，</span></span><br><span class="line"><span class="comment"> * 并将交换后i之后序列按升序排列，若整个序列都为降序则反转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode31</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">               i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index = nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=nums.length-<span class="number">1</span>;j&gt;=i;j--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[j]&gt;index)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i-<span class="number">1</span>];</span><br><span class="line">            nums[i-<span class="number">1</span>]=nums[j];</span><br><span class="line">            nums[j]=temp;</span><br><span class="line">            Arrays.sort(nums,i,nums.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> leetcode31().nextPermutation(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 692】Top K Frequent Words 前K个高频单词</title>
      <link href="/2018/09/10/%E3%80%90LeetCode%20692%E3%80%91Top%20K%20Frequent%20Words%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/"/>
      <url>/2018/09/10/%E3%80%90LeetCode%20692%E3%80%91Top%20K%20Frequent%20Words%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给一非空的单词列表，返回前 k 个出现次数最多的单词。</span></span><br><span class="line"><span class="comment"> * 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 放到map中按次数排序再按字典序排序</span></span><br><span class="line"><span class="comment"> * 重写比较器，可以这么写Comparator.comparing(Map.Entry&lt;String,Integer&gt;::getValue)</span></span><br><span class="line"><span class="comment"> * 但是感觉不灵活，也不好用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode692</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  List&lt;String&gt; <span class="title">topKFrequent</span> <span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(words[i]))</span><br><span class="line">                map.put(words[i], map.get(words[i])+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(words[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Map.Entry&lt;String,Integer&gt;&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(map.entrySet());</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//次数不相等按次数排序</span></span><br><span class="line">                <span class="keyword">if</span>(o1.getValue()!=o2.getValue())</span><br><span class="line">                    <span class="keyword">return</span> o1.getValue().compareTo(o2.getValue());</span><br><span class="line">                <span class="comment">//相等按字典序排序</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> -o1.getKey().compareTo(o2.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;k&gt;<span class="number">0</span>;k--,i--)&#123;</span><br><span class="line">            res.add(list.get(i).getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">            <span class="keyword">new</span> leetcode692().topKFrequent(<span class="keyword">new</span> String[]&#123; <span class="string">"a"</span>, <span class="string">"b"</span>,<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"b"</span>,<span class="string">"d"</span>&#125;,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 476】Number Complement  数字的补数</title>
      <link href="/2018/09/10/%E3%80%90LeetCode%20476%E3%80%91Number%20Complement%20%20%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/"/>
      <url>/2018/09/10/%E3%80%90LeetCode%20476%E3%80%91Number%20Complement%20%20%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</span></span><br><span class="line"><span class="comment"> * 注意:</span></span><br><span class="line"><span class="comment"> * 给定的整数保证在32位带符号整数的范围内,</span></span><br><span class="line"><span class="comment"> * 你可以假定二进制数不包含前导零位。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对二进制取反，其实就是与相同位数全为1的二进制异或</span></span><br><span class="line"><span class="comment"> * Integer.highestOneBit(n),比如n二进制位1100，则计算出的结果为10000，所以全为1用前面所求的值-1即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode476</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findComplement</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask = (Integer.highestOneBit(num) &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mask ^ num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(leetcode476.findComplement(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 62】Unique Paths 不同路径</title>
      <link href="/2018/09/10/%E3%80%90LeetCode%2062%E3%80%91Unique%20Paths%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
      <url>/2018/09/10/%E3%80%90LeetCode%2062%E3%80%91Unique%20Paths%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</span></span><br><span class="line"><span class="comment"> * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</span></span><br><span class="line"><span class="comment"> * 问总共有多少条不同的路径？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dp[i][j]表示从原点到i，j总路径数目</span></span><br><span class="line"><span class="comment"> * 转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1] 到i，j的路径数目等于到上面一个点与左面一个点数目之和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode62</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span> <span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                System.out.print(dp[i][j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * O(n)空间复杂度</span></span><br><span class="line"><span class="comment">     * 7=6+1</span></span><br><span class="line"><span class="comment">     * 7上一轮为1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths2</span> <span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> leetcode62().uniquePaths(<span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 31】Next Permutation 下一个排列</title>
      <link href="/2018/09/10/%E3%80%90LeetCode%2031%E3%80%91Next%20Permutation%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
      <url>/2018/09/10/%E3%80%90LeetCode%2031%E3%80%91Next%20Permutation%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</span></span><br><span class="line"><span class="comment"> * 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</span></span><br><span class="line"><span class="comment"> * 必须原地修改，只允许使用额外常数空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 下一个全排列就是找到比当前数大的最小值，找到降序排列开始的位置，记为i，从i到n找到比nums[i-1]大的最小值与i-1交换，</span></span><br><span class="line"><span class="comment"> * 并将交换后i之后序列按升序排列，若整个序列都为降序则反转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode31</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">               i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index = nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=nums.length-<span class="number">1</span>;j&gt;=i;j--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[j]&gt;index)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i-<span class="number">1</span>];</span><br><span class="line">            nums[i-<span class="number">1</span>]=nums[j];</span><br><span class="line">            nums[j]=temp;</span><br><span class="line">            Arrays.sort(nums,i,nums.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> leetcode31().nextPermutation(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 31】Merge Intervals 合并区间</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%2031%E3%80%91Merge%20Intervals%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%2031%E3%80%91Merge%20Intervals%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给出一个区间的集合，请合并所有重叠的区间。</span></span><br><span class="line"><span class="comment"> * 示例 1:</span></span><br><span class="line"><span class="comment"> * 输入: [[1,3],[2,6],[8,10],[15,18]]</span></span><br><span class="line"><span class="comment"> * 输出: [[1,6],[8,10],[15,18]]</span></span><br><span class="line"><span class="comment"> * 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> * 输入: [[1,4],[4,5]]</span></span><br><span class="line"><span class="comment"> * 输出: [[1,5]]</span></span><br><span class="line"><span class="comment"> * 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 按照左边界排序，然后两两合并</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode56</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        Interval() &#123;</span><br><span class="line">            start = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">            start = s;</span><br><span class="line">            end = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        Collections.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval o1, Interval o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1.start, o2.start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            Interval left = intervals.get(i - <span class="number">1</span>);</span><br><span class="line">            Interval right = intervals.get(i);</span><br><span class="line">            Interval mergeInterval = <span class="keyword">new</span> Interval();</span><br><span class="line">            <span class="keyword">if</span> (right.start &lt;= left.end) &#123;</span><br><span class="line">                mergeInterval = <span class="keyword">new</span> Interval(left.start, Math.max(left.end, right.end));</span><br><span class="line">                intervals.set(i,mergeInterval);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                res.add(intervals.get(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(intervals.get(intervals.size() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 55】Jump Game 跳跃游戏</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%2055%E3%80%91Jump%20Game%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%2055%E3%80%91Jump%20Game%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个非负整数数组，你最初位于数组的第一个位置。</span></span><br><span class="line"><span class="comment"> * 数组中的每个元素代表你在该位置可以跳跃的最大长度。</span></span><br><span class="line"><span class="comment"> * 判断你是否能够到达最后一个位置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不断更新你能到达的最大位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode55</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意是小于max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">            max = Math.max(max,nums[i]+i);</span><br><span class="line">            <span class="keyword">if</span> (max &gt;= nums.length-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 8】String to Integer (atoi) 字符串转整数 (atoi)</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%208%E3%80%91String%20to%20Integer%20(atoi)%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%20(atoi)/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%208%E3%80%91String%20to%20Integer%20(atoi)%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%20(atoi)/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 atoi，将字符串转为整数。</span></span><br><span class="line"><span class="comment"> * 在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来,</span></span><br><span class="line"><span class="comment"> * 这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</span></span><br><span class="line"><span class="comment"> * 字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。</span></span><br><span class="line"><span class="comment"> * 当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。</span></span><br><span class="line"><span class="comment"> * 若函数不能执行有效的转换，返回 0。</span></span><br><span class="line"><span class="comment"> * 说明：假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。如果数值超过可表示的范围，则返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) != <span class="string">' '</span>)&#123;</span><br><span class="line">                str =str.substring(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;=<span class="number">2</span>&amp;&amp;str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>&amp;&amp;(str.charAt(<span class="number">1</span>)&lt;<span class="string">'0'</span>|| str.charAt(<span class="number">1</span>)&gt;<span class="string">'9'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">1</span>&amp;&amp; (str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>||str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>)</span><br><span class="line">            str=str.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;=<span class="number">2</span>&amp;&amp;str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>&amp;&amp;(str.charAt(<span class="number">1</span>)&lt;<span class="string">'0'</span>|| str.charAt(<span class="number">1</span>)&gt;<span class="string">'9'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((str.charAt(<span class="number">0</span>)&lt;<span class="string">'0'</span>|| str.charAt(<span class="number">0</span>)&gt;<span class="string">'9'</span>)&amp;&amp;str.charAt(<span class="number">0</span>)!=<span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.equals(String.valueOf(Integer.MAX_VALUE)))</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(str.equals(String.valueOf(Integer.MIN_VALUE)))</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i==<span class="number">0</span> &amp;&amp; str.charAt(i)==<span class="string">'-'</span>) &#123;</span><br><span class="line">                result.append(<span class="string">'-'</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&lt;<span class="string">'0'</span>|| str.charAt(i)&gt;<span class="string">'9'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> f = result.charAt(<span class="number">0</span>);</span><br><span class="line">        String s = <span class="keyword">new</span> StringBuilder(result.reverse().toString().split(<span class="string">"-"</span>)[<span class="number">0</span>]).reverse().toString();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ans = Integer.valueOf(s);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            ans= f==<span class="string">'-'</span>?Integer.MIN_VALUE:Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f==<span class="string">'-'</span>?<span class="number">0</span>-ans:ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">       System.out.print( leetcode8.myAtoi(<span class="string">"-w"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 11】Container With Most Water 盛最多水的容器</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%2011%E3%80%91Container%20With%20Most%20Water%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%2011%E3%80%91Container%20With%20Most%20Water%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，</span></span><br><span class="line"><span class="comment"> * 垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，</span></span><br><span class="line"><span class="comment"> * 使得它们与 x 轴共同构成的容器可以容纳最多的水。</span></span><br><span class="line"><span class="comment"> * 说明：你不能倾斜容器，且 n 的值至少为 2。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最大面积取决于短边，所以每次移动较短的一边即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxArea</span> <span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = Math.min(height[left], height[right]);</span><br><span class="line">            max = Math.max(max, h * (right - left));</span><br><span class="line">            <span class="keyword">if</span> (h == height[left])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []h = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        leetcode11.maxArea(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 53】Maximum Subarray 最大子序和</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%2053%E3%80%91Maximum%20Subarray%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%2053%E3%80%91Maximum%20Subarray%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode53</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            max = Math.max(dp[i], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 40】Combination Sum II 组合总和 II</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%2040%E3%80%91Combination%20Sum%20II%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%2040%E3%80%91Combination%20Sum%20II%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span></span><br><span class="line"><span class="comment"> * candidates 中的每个数字在每个组合中只能使用一次。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 先排序，再去重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode40</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        helper(candidates, target, <span class="number">0</span>, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private void helper(int[] nums, int target, int pos, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; bag) &#123;</span></span><br><span class="line"><span class="comment">//        if (target == 0)</span></span><br><span class="line"><span class="comment">//            res.add(new ArrayList&lt;&gt;(bag));</span></span><br><span class="line"><span class="comment">//        if (target &lt; 0)</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        if (pos &gt;= nums.length)</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        else &#123;</span></span><br><span class="line"><span class="comment">//            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(bag);</span></span><br><span class="line"><span class="comment">//            helper(nums, target, pos + 1, res, bag);</span></span><br><span class="line"><span class="comment">//            bag =temp;</span></span><br><span class="line"><span class="comment">//            bag.add(nums[pos]);</span></span><br><span class="line"><span class="comment">//            helper(nums, target - nums[pos], pos + 1, res, bag);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> pos, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; bag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(bag));</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; pos &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                bag.add(nums[i]);</span><br><span class="line">                helper(nums, target-nums[i], i + <span class="number">1</span>, res, bag);</span><br><span class="line">                bag.remove(bag.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> leetcode40().combinationSum2(<span class="keyword">new</span> <span class="keyword">int</span> []&#123;<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,  <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 26】Remove Duplicates from Sorted Array 删除排序数组中的重复项</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%2026%E3%80%91Remove%20Duplicates%20from%20Sorted%20Array%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%2026%E3%80%91Remove%20Duplicates%20from%20Sorted%20Array%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</span></span><br><span class="line"><span class="comment"> * 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[pos] != nums[i]) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                nums[pos] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 27】Remove Element 移除元素</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%2027%E3%80%91Remove%20Element%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%2027%E3%80%91Remove%20Element%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</span></span><br><span class="line"><span class="comment"> * 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span></span><br><span class="line"><span class="comment"> * 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode27</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = nums[pos];</span><br><span class="line">                nums[pos] = nums[i];</span><br><span class="line">                nums[i] = t;</span><br><span class="line">                count++;</span><br><span class="line">                pos--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 19】Remove Nth Node From End of List 删除链表的倒数第N个节点</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%2019%E3%80%91Remove%20Nth%20Node%20From%20End%20of%20List%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%2019%E3%80%91Remove%20Nth%20Node%20From%20End%20of%20List%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</span></span><br><span class="line"><span class="comment"> * 一趟扫描</span></span><br><span class="line"><span class="comment"> * 两个指针，一个先走n步，然后两个指针同时走，第一个指针到末尾，第二个指针的位置就是倒数第n个节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode19</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode i = head, j = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            j = j.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = i;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="keyword">null</span>) &#123;</span><br><span class="line">            j = j.next;</span><br><span class="line">            temp = i;</span><br><span class="line">            i = i.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp == i) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = i.next;</span><br><span class="line">            i.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 31】Next Permutation 下一个排列</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%20105%E3%80%91Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%20105%E3%80%91Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据一棵树的前序遍历与中序遍历构造二叉树</span></span><br><span class="line"><span class="comment"> * 注意:</span></span><br><span class="line"><span class="comment"> * 你可以假设树中没有重复的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 递归构建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode105</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">     * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">     * int val;</span></span><br><span class="line"><span class="comment">     * TreeNode left;</span></span><br><span class="line"><span class="comment">     * TreeNode right;</span></span><br><span class="line"><span class="comment">     * TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//根据前序和中序构件树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span> <span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span> <span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preS, <span class="keyword">int</span> preE, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inS, <span class="keyword">int</span> inE)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preS &gt; preE || inS &gt; inE)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode res = <span class="keyword">new</span> TreeNode(preorder[preS]);</span><br><span class="line">        <span class="keyword">int</span> pos = inS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = inS; i &lt;= inE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == preorder[preS]) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个preE要算准确</span></span><br><span class="line">        res.left = helper(preorder, preS + <span class="number">1</span>, preS + pos-inS, inorder, inS, pos - <span class="number">1</span>);</span><br><span class="line">        res.right = helper(preorder, preS + pos-inS+<span class="number">1</span>, preE, inorder, pos + <span class="number">1</span>, inE);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 2】Add Two Numbers 两数相加</title>
      <link href="/2018/09/09/LeetCode%202%E3%80%91Add%20Two%20Numbers%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2018/09/09/LeetCode%202%E3%80%91Add%20Two%20Numbers%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</span></span><br><span class="line"><span class="comment"> * 你可以假设除了数字 0 之外，这两个数字都不会以零开头。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span> <span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = res;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dight = l1.val + l2.val;</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode((flag + dight) % <span class="number">10</span>);</span><br><span class="line">            flag = (flag+dight) / <span class="number">10</span>;</span><br><span class="line">            res = res.next;</span><br><span class="line">            <span class="keyword">if</span> (l1.next == <span class="keyword">null</span> &amp;&amp; l2.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1.next == <span class="keyword">null</span>)</span><br><span class="line">                l1.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (l2.next == <span class="keyword">null</span>)</span><br><span class="line">                l2.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1.next == <span class="keyword">null</span> &amp;&amp; l2.next == <span class="keyword">null</span> &amp;&amp; flag != <span class="number">0</span>)</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode(flag);</span><br><span class="line">        <span class="keyword">return</span> temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = <span class="keyword">new</span> ListNode(<span class="number">9</span>);</span><br><span class="line">        ListNode p2 = <span class="keyword">new</span> ListNode(<span class="number">9</span>);</span><br><span class="line">        p1.next = p2;</span><br><span class="line">        ListNode q1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        leetcode2.addTwoNumbers(q1, p1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 35】Search Insert Position 搜索插入位置</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%2035%E3%80%91Search%20Insert%20Position%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%2035%E3%80%91Search%20Insert%20Position%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</span></span><br><span class="line"><span class="comment"> * 你可以假设数组中无重复元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二分查找下界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode35</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boundSearch(nums,<span class="number">0</span>,nums.length,target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">boundSearch</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left =mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 367】Valid Perfect Square 有效的完全平方数</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%20367%E3%80%91Valid%20Perfect%20Square%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%20/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%20367%E3%80%91Valid%20Perfect%20Square%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%20/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</span></span><br><span class="line"><span class="comment"> * 说明：不要使用任何内置的库函数，如  sqrt。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * 一个数的平方根一定小于这个数的一半</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode367</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> right = num / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid * mid == num)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid &lt; num)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 39】 Combination Sum 组合总和</title>
      <link href="/2018/09/09/%E3%80%90LeetCode%2039%E3%80%91%20Combination%20Sum%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
      <url>/2018/09/09/%E3%80%90LeetCode%2039%E3%80%91%20Combination%20Sum%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”<br>Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。</em>  </p></blockquote></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span></span><br><span class="line"><span class="comment"> * candidates 中的数字可以无限制重复被选取。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dfs即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode39</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum (<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        helper(res, <span class="keyword">new</span> LinkedList&lt;Integer&gt;(), target, candidates,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span> <span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; bag, <span class="keyword">int</span> target, <span class="keyword">int</span>[] nums,<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(bag);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line">                List&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;(bag);</span><br><span class="line">                bag.add(nums[i]);</span><br><span class="line">                helper(res, bag, target - nums[i], nums,i);</span><br><span class="line">                bag = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LCS(substring) | LCS(subsequence) | LIS</title>
      <link href="/2018/09/04/LCS(%E5%AD%90%E4%B8%B2)%E3%80%81LCS(%E5%AD%90%E5%BA%8F%E5%88%97)%E3%80%81LIS%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/04/LCS(%E5%AD%90%E4%B8%B2)%E3%80%81LCS(%E5%AD%90%E5%BA%8F%E5%88%97)%E3%80%81LIS%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="LongestCommonSubstring-最长公共子串"><a href="#LongestCommonSubstring-最长公共子串" class="headerlink" title="LongestCommonSubstring 最长公共子串"></a>LongestCommonSubstring 最长公共子串</h1><h2 id="动态规划解法："><a href="#动态规划解法：" class="headerlink" title="动态规划解法："></a>动态规划解法：</h2><p>dp[i][j]表示以si和tj结尾的公共子串的最大长度；<br>则转移方程为：<br>dp[i][j] = si == tj ? 1 : 0 , i==0||j==0<br>dp[i][j] = s1[i] == s2[j] ? dp[i-1][j-1]+1 : 0 ,other</p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长公共子串</span></span><br><span class="line"><span class="comment"> * dp[i][j]表示以以i、j结尾的以s1[i]、s2[j]为结尾的相同子串的最大长度</span></span><br><span class="line"><span class="comment"> * dp[i][j] = s1[i] == s2[j] ? 1 : 0 ,i==0||j==0</span></span><br><span class="line"><span class="comment"> * dp[i][j] = s1[i] == s2[j] ? dp[i-1][j-1]+1 : 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestCommonSubstring</span> <span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()][s2.length()];</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = s1.charAt(i) == s2.charAt(j) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = s1.charAt(i) == s2.charAt(j) ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                max = Math.max(max,dp[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(max==dp[i][j])&#123;</span><br><span class="line">                    x=i;</span><br><span class="line">                    y=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x,j=y;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;dp[i][j]&gt;=<span class="number">1</span>;i--,j--)</span><br><span class="line">            sb.append(s1.charAt(i));</span><br><span class="line">        System.out.println(sb.reverse().toString());</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        System.out.println(LCSubstring.longestCommonSubstring(<span class="string">"acbcbce"</span>,<span class="string">"abcbced"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>NOTE</strong><br>輸出最大子串：记录最大子串值和位置，沿对角线遍历（–1；–j），因为子串是连续的正确路径只会是对角线</p><h1 id="LongesetCommonSubsequence-最长公共子序列"><a href="#LongesetCommonSubsequence-最长公共子序列" class="headerlink" title="LongesetCommonSubsequence 最长公共子序列"></a>LongesetCommonSubsequence 最长公共子序列</h1><h2 id="动态规划解法：-1"><a href="#动态规划解法：-1" class="headerlink" title="动态规划解法："></a>动态规划解法：</h2><p>dp[i][j]表示s0…si与t0…tj最长公共子序列<br>转移方程：<br>dp[i][j] =  s[i]== t[j] ? 1 : 0, i==0 and j==0;<br>dp[i][j] =  s[i]== t[j] ? 1 : dp[i == 0 ? 0 : i - 1][j == 0 ? 0 : j - 1],i==0 or j==0 and i!=j;<br>dp[i][j] =  dp[i-1][j-1] + 1, s[i] == t[j];<br>dp[i][j] = max(dp[i-1][j], dp[i][j-1]), s[i] != t[j];</p><h2 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE:"></a>CODE:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LongestCommonSubsequence</span> <span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()][s2.length()];</span><br><span class="line">       <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                   dp[i][j] = s1.charAt(i) == s2.charAt(j) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j))</span><br><span class="line">                       dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       dp[i][j] = dp[i == <span class="number">0</span> ? <span class="number">0</span> : i - <span class="number">1</span>][j == <span class="number">0</span> ? <span class="number">0</span> : j - <span class="number">1</span>];</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j))</span><br><span class="line">                       dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">               &#125;</span><br><span class="line">               max = Math.max(max, dp[i][j]);</span><br><span class="line">               System.out.print(dp[i][j]);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showSubsequence</span> <span class="params">(<span class="keyword">int</span>[][] dp, String s, String t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = s.length() - <span class="number">1</span>, j = t.length() - <span class="number">1</span>;</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">               sb.append(s.charAt(i));</span><br><span class="line">               ++i;</span><br><span class="line">               ++j;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>NOTE</strong>:关于输出，从dp表最后一位开始遍历，若相对的字符相等则添加，遍历–i与–j，若不等，比较–i，j与i，–j大小，遍历大者，<br>若相等（搞清楚后补充）。。。</p><h1 id="LIS-最长非递减序列"><a href="#LIS-最长非递减序列" class="headerlink" title="LIS 最长非递减序列"></a>LIS 最长非递减序列</h1><h2 id="动态规划解法：-2"><a href="#动态规划解法：-2" class="headerlink" title="动态规划解法："></a>动态规划解法：</h2><p>dp[i]表示里nums[i]为结尾的lis<br>转移方程：<br>dp[i] = max(dp[i],d[j]+1),s[j]&lt;=s[i]</p><h2 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE:"></a>CODE:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt;= nums[i])</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(dp[i], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="贪心-二分："><a href="#贪心-二分：" class="headerlink" title="贪心+二分："></a>贪心+二分：</h2><p>贪心：使得加入最后一位的值尽可能的小，这样序列才更容易增加<br>二分：搜索当前添加元素在已添加数组的下边界（加入的位置，数组都是排好序的）<br>将元素加入res数组，如果带加入的数字大于res数组的最后一位，则直接添加，否则二分查找要替换的位置,最后res数组大小即为结果（注意res数组内容并不是要求数列）</p><h2 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE:"></a>CODE:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 贪心+二分 nlogn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LIS</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        res[size++] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= res[size - <span class="number">1</span>]) &#123;</span><br><span class="line">                res[size++] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[lower_bound(<span class="number">0</span>, size - <span class="number">1</span>, res, nums[i])] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查下界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lower_bound</span> <span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并查集</title>
      <link href="/2018/09/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2018/09/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="并查集-union-find"><a href="#并查集-union-find" class="headerlink" title="并查集 union-find"></a>并查集 union-find</h1><p>并查集其实就是构建一个森林，对有公共父节点的多叉树合并。<br><strong>问题</strong>：假如有1-10个人，互相认识的人构成一个朋友圈，两个朋友圈中没有相互认识的两个人，问能够构成几个盆友圈。</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>开一个size数组，下标代表每个人所认识的人数，parent数组下标代表自己的父节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">unionFind</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span> <span class="params">(List&lt;List&lt;Integer&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] size = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size.length; i++) &#123;</span><br><span class="line">            size[i] = <span class="number">0</span>;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).size() != <span class="number">0</span>) &#123;</span><br><span class="line">                Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (parent[i] != i)</span><br><span class="line">                    set.add(parent[i]);</span><br><span class="line">                <span class="keyword">for</span> (Integer t : list.get(i)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> root = find(t, parent);</span><br><span class="line">                    <span class="keyword">if</span> (root != t) &#123;</span><br><span class="line">                        set.add(root);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (parent[i] != t) &#123;</span><br><span class="line">                        parent[t] = i;</span><br><span class="line">                        size[i]++;</span><br><span class="line">                        size[t]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (Integer t : set) &#123;</span><br><span class="line">                    union(t, i, size, parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] != find(i, parent)) &#123;</span><br><span class="line">                size[i] += size[parent[i]];</span><br><span class="line">                size[parent[i]] = -<span class="number">1</span>;</span><br><span class="line">                parent[i] = find(i, parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (size[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找自己的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>[] parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] == x)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> find(parent[x], parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并有相同父节点的两棵树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] size, <span class="keyword">int</span>[] parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xparent = find(l, parent);</span><br><span class="line">        <span class="keyword">int</span> yparent = find(r, parent);</span><br><span class="line">        <span class="keyword">if</span> (xparent == yparent)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(i, parent) == yparent) &#123;</span><br><span class="line">                parent[i] = xparent;</span><br><span class="line">                size[xparent]++;</span><br><span class="line">                size[yparent]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>欧几里得算法和牛顿迭代法</title>
      <link href="/2018/08/28/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%92%8C%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
      <url>/2018/08/28/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%92%8C%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="欧几里得算法和牛顿迭代法"><a href="#欧几里得算法和牛顿迭代法" class="headerlink" title="欧几里得算法和牛顿迭代法"></a>欧几里得算法和牛顿迭代法</h1><h2 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h2><p>辗转相除法：f(x,y) = f(y,x%y),x和y的最大公约数和y和x%的最大公约数相同<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Gcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a % b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="求平方根"><a href="#求平方根" class="headerlink" title="求平方根"></a>求平方根</h2><p>牛顿迭代法： k=(k+x/k)/2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Sqrt</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> last=x;</span><br><span class="line">        <span class="keyword">while</span>(Math.abs(res-last)&gt;<span class="number">0.000000001</span>)&#123;</span><br><span class="line">            res = last;</span><br><span class="line">            last = (res+(x/res))/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>之前也听说卡马克快速平方根倒数算法，好奇这几个平方根算法哪个更快<br>cmark:    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">cmark</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i;</span><br><span class="line">       <span class="keyword">float</span> x2, y;</span><br><span class="line">       <span class="keyword">float</span> threehalfs = <span class="number">1.5F</span>;</span><br><span class="line">       x2 = number * <span class="number">0.5F</span>;</span><br><span class="line">       y = number;</span><br><span class="line">       i = Float.floatToRawIntBits(y); <span class="comment">// evil floating point bit level hacking</span></span><br><span class="line">       i = <span class="number">0x5f3759df</span> - (i &gt;&gt; <span class="number">1</span>); <span class="comment">// what the fuck?</span></span><br><span class="line">       y = Float.intBitsToFloat(i);</span><br><span class="line">       y = y * (threehalfs - (x2 * y * y)); <span class="comment">// 1st iteration</span></span><br><span class="line">       y = y * (threehalfs - (x2 * y * y)); <span class="comment">// 2nd iteration, this can be removed</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span> / y;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果是库函数最快，其次是牛顿迭代法（和库函数差不多），卡马克稍慢，啊哈哈哈</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 74】Search a 2D Matrix 搜索二维矩阵</title>
      <link href="/2018/08/28/%E3%80%90LeetCode%2074%E3%80%91Search%20a%202D%20Matrix%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20/"/>
      <url>/2018/08/28/%E3%80%90LeetCode%2074%E3%80%91Search%20a%202D%20Matrix%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20/</url>
      <content type="html"><![CDATA[<h1 id="【LeetCode-74】Search-a-2D-Matrix-搜索二维矩阵"><a href="#【LeetCode-74】Search-a-2D-Matrix-搜索二维矩阵" class="headerlink" title="【LeetCode 74】Search a 2D Matrix 搜索二维矩阵"></a>【LeetCode 74】Search a 2D Matrix 搜索二维矩阵</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。</p><p><strong>说明</strong>：解集不能包含重复的子集。  </p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h4><pre><code>输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 3输出: true</code></pre><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p><strong>Solution</strong>: 二维矩阵从左到右、从上到下均为升序，可以用两次二分查找，先定位到元素所在行，再在本行查找元素即可。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">searchMatrix</span> <span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>{        <span class="keyword">int</span> n = matrix.length;        <span class="keyword">if</span>(n==<span class="number">0</span>)            <span class="keyword">return</span> <span class="keyword">false</span>;        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length;        <span class="keyword">if</span>(m==<span class="number">0</span>)            <span class="keyword">return</span> <span class="keyword">false</span>;        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>, midColumn = <span class="number">0</span>;        <span class="keyword">while</span> (i &lt;= j) {            midColumn = (i + j) / <span class="number">2</span>;            <span class="keyword">if</span> (matrix[midColumn][<span class="number">0</span>] &lt;= target &amp;&amp; target &lt;= matrix[midColumn][m - <span class="number">1</span>])                <span class="keyword">break</span>;            <span class="keyword">if</span>(target&lt;matrix[midColumn][<span class="number">0</span>])                j=midColumn-<span class="number">1</span>;            <span class="keyword">else</span>                i=midColumn+<span class="number">1</span>;        }        <span class="keyword">if</span> (i &gt; j)            <span class="keyword">return</span> <span class="keyword">false</span>;        <span class="keyword">int</span> p = <span class="number">0</span>, q = m - <span class="number">1</span>, midRow = <span class="number">0</span>;        <span class="keyword">while</span> (p &lt;= q) {            midRow = (p + q) / <span class="number">2</span>;            <span class="keyword">if</span> (matrix[midColumn][midRow] == target)                <span class="keyword">return</span> <span class="keyword">true</span>;            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[midColumn][midRow]&lt;target)                p=midRow+<span class="number">1</span>;            <span class="keyword">else</span>                q=midRow-<span class="number">1</span>;        }        <span class="keyword">return</span> <span class="keyword">false</span>;    }}  </code></pre>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode，Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 90】Subsets II 子集II</title>
      <link href="/2018/08/24/%E3%80%90LeetCode%2090%E3%80%91Subsets%20II%20%E5%AD%90%E9%9B%86II/"/>
      <url>/2018/08/24/%E3%80%90LeetCode%2090%E3%80%91Subsets%20II%20%E5%AD%90%E9%9B%86II/</url>
      <content type="html"><![CDATA[<h1 id="【LeetCode-90】Subsets-II-子集II"><a href="#【LeetCode-90】Subsets-II-子集II" class="headerlink" title="【LeetCode 90】Subsets II 子集II"></a>【LeetCode 90】Subsets II 子集II</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p><strong>说明</strong>：解集不能包含重复的子集。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p><strong>Solution</strong>: 这道问题相对于<a href="http://techone577.cn/2018/05/24/[LeetCode%2078]Subsets%20%E5%AD%90%E9%9B%86/" target="_blank" rel="noopener">leetcode78</a>差别在于包含重复元素，所以这道题要解决的就是去重，也就是dfs的时候减枝，考虑序列1，2，2，2，当要回溯到1，2时，遍历下一位判断与上一位是否相同，若相同跳过即可去重，当然这么做的前提条件是原序列是有序的，所以要在原序列做个排序。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup (<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        helper(res, <span class="keyword">new</span> LinkedList&lt;Integer&gt;(), <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span> <span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; bag, <span class="keyword">int</span> pos, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(bag));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; pos &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;(bag);</span><br><span class="line">            bag.add(nums[i]);</span><br><span class="line">            helper(res, bag, i + <span class="number">1</span>, nums);</span><br><span class="line">            bag = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Jdk动态代理实现自定义拦截器</title>
      <link href="/2018/08/22/%E4%BD%BF%E7%94%A8Jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2018/08/22/%E4%BD%BF%E7%94%A8Jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="使用Jdk动态代理实现自定义拦截器"><a href="#使用Jdk动态代理实现自定义拦截器" class="headerlink" title="使用Jdk动态代理实现自定义拦截器"></a>使用Jdk动态代理实现自定义拦截器</h1><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUser</span> </span>{    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;}</code></pre><h3 id="实现类："><a href="#实现类：" class="headerlink" title="实现类："></a>实现类：</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>{    <span class="keyword">private</span> String name;    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>{        <span class="keyword">this</span>.name=name;    }    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span> <span class="params">()</span> </span>{        <span class="keyword">return</span> name;    }}</code></pre><h3 id="自定义拦截器接口："><a href="#自定义拦截器接口：" class="headerlink" title="自定义拦截器接口："></a>自定义拦截器接口：</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>{     <span class="function"><span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method,Object []args)</span></span>;     <span class="function"><span class="keyword">void</span> <span class="title">around</span> <span class="params">(Object proxy,Object target,Method method,Object []args)</span></span>;     <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Object []args)</span></span>;}</code></pre><h3 id="拦截器实现类：-在调用方法前做了个简单的属性校验"><a href="#拦截器实现类：-在调用方法前做了个简单的属性校验" class="headerlink" title="拦截器实现类： (在调用方法前做了个简单的属性校验)"></a>拦截器实现类： (在调用方法前做了个简单的属性校验)</h3><p>这里可以实现多个拦截器实现责任链模式，<strong>target的代理是proxy1，proxy1的代理是proxy2，proxy2的代理是proxy3，这样就可以实现顺序拦截（好处是可以再责任链上任意位置添加拦截，缺点是代理和反射太多性能不高）</strong></p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span> <span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>{        System.out.println(<span class="string">"before"</span>);        <span class="keyword">if</span> (checkProperties(target))            <span class="keyword">return</span> <span class="keyword">true</span>;        <span class="keyword">return</span> <span class="keyword">false</span>;    }    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span> <span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>{        System.out.println(<span class="string">"around"</span>);    }    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span> <span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>{        System.out.println(<span class="string">"After"</span>);    }    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkProperties</span> <span class="params">(Object object)</span> </span>{        Field[] fields = object.getClass().getDeclaredFields();        <span class="keyword">try</span> {            <span class="keyword">for</span> (Field field : fields) {                field.setAccessible(<span class="keyword">true</span>);                <span class="keyword">if</span> (field.get(object).equals(<span class="string">""</span>))                    <span class="keyword">return</span> <span class="keyword">false</span>;            }        } <span class="keyword">catch</span> (Exception e) {        }        <span class="keyword">return</span> <span class="keyword">true</span>;    }}</code></pre><h3 id="实现InvocationHandler"><a href="#实现InvocationHandler" class="headerlink" title="实现InvocationHandler:"></a>实现InvocationHandler:</h3><p>流程如下：<br><img src="/img/interceptorFlowChart.png" alt="流程图"></p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>{    <span class="keyword">private</span> Object target;    <span class="keyword">private</span> Class clazz;    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object t,Class c)</span></span>{        <span class="keyword">this</span>.target = t;        <span class="keyword">this</span>.clazz = c;    }    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">bind</span><span class="params">(Object target,Class clazz)</span></span>{        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),<span class="keyword">new</span> MyInvocationHandler(target,clazz));    }    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span> <span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{        <span class="keyword">if</span>(<span class="keyword">this</span>.clazz==<span class="keyword">null</span>)            <span class="keyword">return</span> method.invoke(target,args);        Object result=<span class="keyword">null</span>;        Interceptor interceptor = (Interceptor) clazz.newInstance();        <span class="keyword">if</span>(interceptor.before(proxy,target,method,args)){            result = method.invoke(target,args);        }<span class="keyword">else</span>{            interceptor.around(proxy,target,method,args);        }        interceptor.after(proxy,target,method,args);        <span class="keyword">return</span> result;    }}</code></pre><h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>{        IUser u = <span class="keyword">new</span> User(<span class="string">""</span>);        IUser proxy = (IUser)MyInvocationHandler.bind(u,MyInterceptor.class);        proxy.getName();    }}</code></pre><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果:"></a>运行结果:</h3><p><img src="/img/interceptor.png" alt="结果"></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 784】Letter Case Permutation字母大小写全排列</title>
      <link href="/2018/08/21/%5BLeetCode%20784%5DLetter%20Case%20Permutation%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2018/08/21/%5BLeetCode%20784%5DLetter%20Case%20Permutation%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-784-Letter-Case-Permutation字母大小写全排列"><a href="#LeetCode-784-Letter-Case-Permutation字母大小写全排列" class="headerlink" title="[LeetCode 784]Letter Case Permutation字母大小写全排列"></a>[LeetCode 784]Letter Case Permutation字母大小写全排列</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: S = &quot;a1b2&quot;</span><br><span class="line">输出: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span><br><span class="line"></span><br><span class="line">输入: S = &quot;3z4&quot;</span><br><span class="line">输出: [&quot;3z4&quot;, &quot;3Z4&quot;]</span><br><span class="line"></span><br><span class="line">输入: S = &quot;12345&quot;</span><br><span class="line">输出: [&quot;12345&quot;]</span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>S 的长度不超过12。<br>S 仅由数字和字母组成。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p><strong>Solution </strong>: 深度优先搜索即可解决</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><figcaption><span>beat 84%</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">letterCasePermutation</span> <span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        letterCasePermutationHelper(res, S, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">letterCasePermutationHelper</span> <span class="params">(List&lt;String&gt; list, String s, <span class="keyword">int</span> pos, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= <span class="string">'9'</span>)</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//添加原来的字母</span></span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">                StringBuilder t = <span class="keyword">new</span> StringBuilder(sb.toString());</span><br><span class="line">                letterCasePermutationHelper(list, s, i + <span class="number">1</span>, sb);</span><br><span class="line">                sb = t;</span><br><span class="line">                <span class="comment">//添加转变后的字母</span></span><br><span class="line">                sb.deleteCharAt(i);</span><br><span class="line">                sb.append(transLeeterCase(s.charAt(i)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">transLeeterCase</span> <span class="params">(<span class="keyword">char</span> letter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> res = <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'a'</span> &lt;= letter &amp;&amp; letter &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">            res = (<span class="keyword">char</span>) (letter-(<span class="string">'a'</span>-<span class="string">'A'</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= letter &amp;&amp; letter &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">            res = (<span class="keyword">char</span>) (letter+<span class="string">'a'</span>-<span class="string">'A'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 15】3sum 三数之和</title>
      <link href="/2018/08/20/%E3%80%90LeetCode%2015%E3%80%913sum%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2018/08/20/%E3%80%90LeetCode%2015%E3%80%913sum%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<h1 id="【LeetCode-15】3sum-三数之和"><a href="#【LeetCode-15】3sum-三数之和" class="headerlink" title="【LeetCode 15】3sum 三数之和"></a>【LeetCode 15】3sum 三数之和</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p><strong>说明</strong>：答案中不可以包含重复的三元组。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p><strong>Solution 1</strong>: 首先想到的是以2sum为基础的利用集合解决的方法，用一个map存储所有元素，但是不能判断map重元素是否出现多次，两层循环，外层循环即为待处理的num，如果当前num在之前被处理过则跳过（用set除重复），与当前元素匹配的剩余两个元素组成的不重复三元组只可能出现在当前num之后，还要判断第三个元素与第二个元素并不为同一个元素，map中若有重复元素，其下标值为后放入者，这样便可判断不能判断map重元素是否出现多次问题，但是这种解决方法最耗时的地方在于结果集合去重，即每个结果先排序在放入set去重。        </p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><figcaption><span>beat 14%</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">      Map&lt;Integer, Integer&gt; twosum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            twosum.put(nums[i], i);</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; s = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (set.contains(target))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            set.add(target);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (twosum.containsKey(target - nums[j])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (twosum.get(target - nums[j]) &gt; i + <span class="number">1</span> &amp;&amp; twosum.get(target - nums[j]) != j) &#123;</span><br><span class="line">                        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                        list.add(nums[i]);</span><br><span class="line">                        list.add(nums[j]);</span><br><span class="line">                        list.add(target - nums[j]);</span><br><span class="line">                        Collections.sort(list);</span><br><span class="line">                        s.add(list);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; l : s)</span><br><span class="line">            res.add(l);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution 2</strong>：<br>先将数组排序，这样跳过已经处理过的元素与与上一个元素比较即可，外层循环记录待处理的num，内层循环用两个指针跳过重复元素，这样避免了结果解得去重；</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><figcaption><span>beat 89%</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"> List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; length; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums[k] &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k-<span class="number">1</span>] )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> j = length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( i &lt; j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span> ( sum &lt; <span class="number">0</span> )++i;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( sum &gt; <span class="number">0</span> )--j;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    lists.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line">                    <span class="keyword">do</span>&#123; ++i; &#125; <span class="keyword">while</span>( i &lt; j &amp;&amp; nums[i-<span class="number">1</span>] == nums[i] );</span><br><span class="line">                    <span class="keyword">do</span>&#123; --j; &#125; <span class="keyword">while</span>( i &lt; j  &amp;&amp; nums[j] == nums[j+<span class="number">1</span>] );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jdk动态代理和Cglib动态代理</title>
      <link href="/2018/08/20/Jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2018/08/20/Jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="Jdk动态代理和Cglib动态代理"><a href="#Jdk动态代理和Cglib动态代理" class="headerlink" title="Jdk动态代理和Cglib动态代理"></a>Jdk动态代理和Cglib动态代理</h1><h3 id="Jdk动态代理："><a href="#Jdk动态代理：" class="headerlink" title="Jdk动态代理："></a>Jdk动态代理：</h3><p>只能为接口实现代理</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现InvocationHandler接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span> <span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.print(method.getName()+<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        IUser u = <span class="keyword">new</span> User();</span><br><span class="line">        MyInvocationHandler invocationHandler = <span class="keyword">new</span> MyInvocationHandler(u);</span><br><span class="line">        IUser proxy = (IUser) Proxy.newProxyInstance(u.getClass().getClassLoader(),u.getClass().getInterfaces(),invocationHandler);</span><br><span class="line">        System.out.print(proxy.getName(<span class="string">"hello"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cglib动态代理："><a href="#cglib动态代理：" class="headerlink" title="cglib动态代理："></a>cglib动态代理：</h3><p>为类生成代理，被代理类无需实现接口，<br>引入jar包版本asm3.31对应cglib-2.2.2（对应其他版本cglib可能会有冲突，）<br> 被代理类不能用final修饰，要生成子类</p><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现MethodInterceptor接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCglib</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">//创建加强器，用来创建动态代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">//设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建动态代理类对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现回调方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span> <span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(o,objects);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        UserCglib userCglib = <span class="keyword">new</span> UserCglib();</span><br><span class="line">        User proxy = (User)userCglib.getInstance(user);</span><br><span class="line">        System.out.print(proxy.getName(<span class="string">"hello"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 5】Longest Palindromic Substring 最长回文子串</title>
      <link href="/2018/08/12/%5BLeetCode%205%5DLongest%20Palindromic%20Substring%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2018/08/12/%5BLeetCode%205%5DLongest%20Palindromic%20Substring%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-5-Longest-Palindromic-Substring-最长回文子串"><a href="#LeetCode-5-Longest-Palindromic-Substring-最长回文子串" class="headerlink" title="[LeetCode 5]Longest Palindromic Substring 最长回文子串"></a>[LeetCode 5]Longest Palindromic Substring 最长回文子串</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p><p><strong>说明</strong>：解集不能包含重复的子集。  </p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure><h4 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p><strong>Solution 1</strong>:<br>之前的考虑，最长回文字符串即字符串与倒置的字符串的最长公共字符串，但是并不正确，考虑acbca；最长公共子字符串dp解法时间复杂度为O(<sub>2</sub>)，dp[i][j]表示从i到j的最长公共子字符串，字符串p1…..pi,q1…..qj转移方程：i/j=0,dp[i][j]=0;q[i]==p[j],dp[i][j]=dp[i-1][j-1]+1;q[i]!=p[j],dp[i][j]=0;</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><figcaption><span>wrong</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = s.length();</span><br><span class="line">        String sRevert = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == sRevert.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    maxLength = Math.max(dp[i][j], maxLength);</span><br><span class="line">                    <span class="keyword">if</span> (maxLength == dp[i][j]) pos = i;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos - <span class="number">1</span>; i &gt; pos - maxLength - <span class="number">1</span>; i--)</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br></pre></td></tr></table></figure><p><strong>Solution 2</strong>：<br>最长回文字符串也有dp做法，不过复杂度也为O(<sub>2</sub>)，所以我选择选择复杂度为线性的manacher算法。manacher算法是基于由中心向两边发散的算法，所以奇偶字符串处理不同，这里采用一个小技巧，在字符串首尾，及各字符间各插入一个未出现的字符使其恒为为奇字符串。定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径,<br><img src="/img/manacher.png" alt=""><br>设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。</p><p>假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (i &lt; mx)  </span><br><span class="line">    p[i] = min(p[2 * id - i], mx - i);</span><br></pre></td></tr></table></figure></p><p>2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><figcaption><span>beat 79%</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        stringBuilder.insert(<span class="number">0</span>, <span class="string">"#"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length() * <span class="number">2</span>; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">            stringBuilder.insert(i + <span class="number">1</span>, <span class="string">"#"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String str = stringBuilder.toString();</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p[] = <span class="keyword">new</span> <span class="keyword">int</span>[str.length()];</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; mx)</span><br><span class="line">                p[i] = Math.min(mx - i, p[<span class="number">2</span> * id - i]);</span><br><span class="line">            <span class="keyword">while</span> (i - p[i] &gt;= <span class="number">0</span> &amp;&amp; i + p[i] &lt;= str.length() - <span class="number">1</span> &amp;&amp; (str.charAt(i - p[i]) == str.charAt(i + p[i])))</span><br><span class="line">                p[i]++;</span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; mx) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, p[i]);</span><br><span class="line">            <span class="keyword">if</span> (max == p[i])</span><br><span class="line">                id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(id) != <span class="string">'#'</span>)</span><br><span class="line">            stringBuilder.append(str.charAt(id));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i+id) != <span class="string">'#'</span>) &#123;</span><br><span class="line">                stringBuilder.append(str.charAt(i + id));</span><br><span class="line">                stringBuilder.insert(<span class="number">0</span>, str.charAt(i + id));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 3】Longest Substring Without Repeating Characters 无重复字符的最长子串</title>
      <link href="/2018/07/16/%5BLeetCode%203%5DLongest%20Substring%20Without%20Repeating%20Characters%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2018/07/16/%5BLeetCode%203%5DLongest%20Substring%20Without%20Repeating%20Characters%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串"><a href="#LeetCode-3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串" class="headerlink" title="[LeetCode 3]Longest Substring Without Repeating Characters 无重复字符的最长子串"></a>[LeetCode 3]Longest Substring Without Repeating Characters 无重复字符的最长子串</h1><h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string, find the length of the longest substring without repeating characters.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3.</span><br><span class="line"></span><br><span class="line">Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1.</span><br><span class="line"></span><br><span class="line">Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><p><strong>说明</strong>：解集不能包含重复的子集。  </p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。</span><br><span class="line"></span><br><span class="line">给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。</span><br><span class="line"></span><br><span class="line">给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列  而不是子串。</span><br></pre></td></tr></table></figure><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p><strong>Solution 1</strong>: 遍历char数组，put到map&lt;字符，字符下标&gt;中，若当前元素在map中，则将下表置为当前元素在map中的重复值的角标+1,继续遍历，复杂度O(N<sup>2</sup>)</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//beat 18%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span> []array=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(array[i]))&#123;</span><br><span class="line">                max=max&gt;map.size()?max:map.size();</span><br><span class="line">                i=map.get(array[i]);</span><br><span class="line">                map.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(array[i],i);</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">        max=max&gt;map.size()?max:map.size();</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution 2</strong>：（优化的滑动窗口）<br>(i,j)作为一个窗口，让j滑动，并将j位置的字符放到map中，当map包含j位置的字符时,(未优化的滑动窗口是让i滑动，直到i，j不包含重复字符串)，i取map中j字符所在位置+1和i的最大值（考虑baab字符串，就明白为什么i取两者之间的大者），向hashmap添加重复元素时会覆盖原来的值。时间复杂度为O(n)。</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//beat 67%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(j)))&#123;</span><br><span class="line">                i=Math.max(map.get(s.charAt(j))+<span class="number">1</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            max=Math.max(max,j-i+<span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j),j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器下载文件</title>
      <link href="/2018/07/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2018/07/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h4 id="浏览器下载文件"><a href="#浏览器下载文件" class="headerlink" title="浏览器下载文件"></a>浏览器下载文件</h4><p>solution:读取文件,设置响应头，写入返回的流<br>前端用http请求而不能用ajax请求(JQuery的ajax函数的返回类型只有xml、text、json、html等类型，没有“流”类型，所以我们要实现ajax下载，不能够使用相应的ajax函数进行文件下载。) （前端用a标签自动点击）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/view"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/download"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTemplate</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//服务器下的相对路径</span></span><br><span class="line">        String path = <span class="string">"WEB-INF/document/template.csv"</span>;</span><br><span class="line">        <span class="comment">//通过相对路径获取真实路径</span></span><br><span class="line">        File csvFile = <span class="keyword">new</span> File(request.getServletContext().getRealPath(path));</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServletOutputStream out = response.getOutputStream();</span><br><span class="line">            FileInputStream csvInputStream = <span class="keyword">new</span> FileInputStream(csvFile);</span><br><span class="line">            BufferedOutputStream outputStream = <span class="keyword">new</span> BufferedOutputStream(out);</span><br><span class="line">            <span class="comment">//让服务器告诉浏览器它发送的数据属于什么文件类型</span></span><br><span class="line">            response.setContentType(<span class="string">"multipart/form-data"</span>);</span><br><span class="line">            <span class="comment">//inline 和 attachment：将文件内容直接显示在页面 attachment：弹出对话框让用户下载</span></span><br><span class="line">            response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;fileName="</span>+<span class="string">"test.csv"</span>);</span><br><span class="line">            response.addHeader(<span class="string">"Content-Length"</span>, String.valueOf(csvFile.length()));</span><br><span class="line">  <span class="comment">//设置缓冲区大小</span></span><br><span class="line">            <span class="keyword">byte</span> []buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((ch = csvInputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                outputStream.write(buffer,<span class="number">0</span>,ch);</span><br><span class="line">            &#125;</span><br><span class="line">            outputStream.flush();</span><br><span class="line">            out.close();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            csvInputStream.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 394】 Decode String 字符串解码</title>
      <link href="/2018/06/01/%5BLeetCode%20394%5DDecode%20String%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
      <url>/2018/06/01/%5BLeetCode%20394%5DDecode%20String%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-394-Decode-String-字符串解码"><a href="#LeetCode-394-Decode-String-字符串解码" class="headerlink" title="[LeetCode 394]Decode String 字符串解码"></a>[LeetCode 394]Decode String 字符串解码</h1><h4 id="Problem-decription"><a href="#Problem-decription" class="headerlink" title="Problem decription:"></a>Problem decription:</h4><p>Given an encoded string, return it’s decoded string.</p><p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p><p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.</span><br><span class="line">s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.</span><br><span class="line">s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 <strong>3a</strong> 或 <strong>2[4]</strong> 的输入。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><pre><code>s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</code></pre><h4 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h4><p>首先想到的是递归，或者是用两个栈的非递归方法，非递归的效率更高一些。<br>一个栈用来保存数字，一个用来保存字符串，以 b3[a]2[c]d] 为例,遍历整个字符串，用t保存当前字符串，count保存当前数字，碰到字母就添加到t中，碰到数字便循环读取并转换成正确的格式，当读取到‘[’时，将count入数字栈，将当前字符入字符栈，并将t清空，当读取到‘]’时，去数字栈顶元素k与字符栈顶元素s，t=s+k个t，直至栈为空结束，t即为所求。</p><p><img src="/img/decodeString1.png" alt="1">  </p><p><img src="/img/decodeString2.png" alt="2"></p><h4 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h4><pre><code class="java"><span class="comment">//beat 50%</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>{        Stack&lt;Integer&gt; sNum=<span class="keyword">new</span> Stack&lt;Integer&gt;();        Stack&lt;String&gt; sStr=<span class="keyword">new</span> Stack&lt;String&gt;();        <span class="keyword">char</span>[] chr=s.toCharArray();        String t=<span class="string">""</span>;        String count=<span class="string">""</span>;        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chr.length;i++){            <span class="keyword">if</span>(chr[i]&gt;=<span class="string">'0'</span> &amp;&amp; chr[i]&lt;=<span class="string">'9'</span>){                <span class="keyword">while</span>(chr[i]!=<span class="string">'['</span>){                    count+=chr[i++];                }                sNum.push(Integer.parseInt(count));                count=<span class="string">""</span>;            }           <span class="keyword">else</span> <span class="keyword">if</span>(chr[i]&lt;<span class="string">'0'</span> || chr[i]&gt;<span class="string">'9'</span> &amp;&amp;chr[i]!=<span class="string">']'</span> &amp;&amp;chr[i]!=<span class="string">'['</span>)                t+=chr[i];           <span class="keyword">if</span>(chr[i]==<span class="string">'['</span>){            sStr.push(t);            t=<span class="string">""</span>;        }            <span class="keyword">if</span>(chr[i]==<span class="string">']'</span>){                <span class="keyword">int</span> k=<span class="number">1</span>;                <span class="keyword">if</span>(!sNum.isEmpty()){                    k=sNum.pop();                String top=sStr.pop();                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)                    top+=t;                  t=top;                    }            }        }        <span class="keyword">return</span> t;    }}</code></pre>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 377】 Combination Sum IV 组合总和 IV</title>
      <link href="/2018/06/01/%5BLeetCode%20377%5DCombinatiion%20Sum%20IV%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20IV/"/>
      <url>/2018/06/01/%5BLeetCode%20377%5DCombinatiion%20Sum%20IV%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20IV/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-377-Combinatiion-Sum-IV-组合总和-IV"><a href="#LeetCode-377-Combinatiion-Sum-IV-组合总和-IV" class="headerlink" title="[LeetCode 377]Combinatiion Sum IV 组合总和 IV"></a>[LeetCode 377]Combinatiion Sum IV 组合总和 IV</h1><h4 id="Problem-decription"><a href="#Problem-decription" class="headerlink" title="Problem decription:"></a>Problem decription:</h4><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. </p><h4 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 2, 3]</span><br><span class="line">target = 4</span><br><span class="line"></span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">Note that different sequences are counted as different combinations.</span><br><span class="line"></span><br><span class="line">Therefore the output is 7.</span><br></pre></td></tr></table></figure><h4 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h4><p>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative numbers?</p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 2, 3]</span><br><span class="line">target = 4</span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line"></span><br><span class="line">因此输出为 7。</span><br></pre></td></tr></table></figure><h4 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h4><p>如果给定的数组中含有负数会怎么样？<br>问题会产生什么变化？<br>我们需要在题目中添加什么限制来允许负数的出现？  </p><h4 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h4><p>使用动态规划和递归均可，创建一个dp数组，dp[i]表示和为i的正整数组合的个数，dp[0]=1,则从i=1到target遍历，对每一个i遍历数组中每个num，若i&gt;=num,则dp[i]+=dp[i-num],表示dp[3]=dp[2]+1 或 dp[1]+2 或 dp[0]+3,将所有情况累加就是dp[3]的结果,对原数组排序可对算法进行优化，当i&lt;num后面则不用判断直接break。(后面给出递归版本)</p><h4 id="Code-动态规划-："><a href="#Code-动态规划-：" class="headerlink" title="Code(动态规划)："></a>Code(动态规划)：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//beat 90%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> []dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;target+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;num)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                dp[i]+=dp[i-num];</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Code-递归-："><a href="#Code-递归-：" class="headerlink" title="Code(递归)："></a>Code(递归)：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;=num)</span><br><span class="line">            count+=combinationSum4(nums,target-num); </span><br><span class="line">            &#125;    </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AC beat 66.7%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(map.containsKey(target))</span><br><span class="line">             <span class="keyword">return</span> map.get(target);</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=num)</span><br><span class="line">                   count+=combinationSum4(nums,target-num); </span><br><span class="line">            &#125;</span><br><span class="line">        map.put(target,count);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 70】Climbing Stairs 爬楼梯</title>
      <link href="/2018/05/25/%5BLeetCode%2070%5DClimbing%20Stairs%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2018/05/25/%5BLeetCode%2070%5DClimbing%20Stairs%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-70-Climbing-Stairs-爬楼梯"><a href="#LeetCode-70-Climbing-Stairs-爬楼梯" class="headerlink" title="[LeetCode 70]Climbing Stairs 爬楼梯"></a>[LeetCode 70]Climbing Stairs 爬楼梯</h1><h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p><strong>Note</strong>: Given n will be a positive integer.  </p><h4 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>假设你正在爬楼梯。需要 n 步你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>说明</strong>：给定 n 是一个正整数。  </p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 步 + 1 步</span><br><span class="line">2.  2 步</span><br></pre></td></tr></table></figure><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p>通过归纳可知符合斐波那契数列。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f2=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line"></span><br><span class="line">            sum=f1+f2;</span><br><span class="line">            f1=f2;</span><br><span class="line">            f2=sum;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 393】UTF-8 Validation UTF-8 编码验证</title>
      <link href="/2018/05/25/%5BLeetCode%20393%5DUTF-8%20Validation%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/"/>
      <url>/2018/05/25/%5BLeetCode%20393%5DUTF-8%20Validation%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-393-UTF-8-Validation-UTF-8-编码验证"><a href="#LeetCode-393-UTF-8-Validation-UTF-8-编码验证" class="headerlink" title="[LeetCode 393]UTF-8 Validation UTF-8 编码验证"></a>[LeetCode 393]UTF-8 Validation UTF-8 编码验证</h1><h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:</p><ul><li>For 1-byte character, the first bit is a 0, followed by its unicode code.  </li><li>For n-bytes character, the first n-bits are all one’s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.<br><strong>This is how the UTF-8 encoding would work:</strong>  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Char. number range  |        UTF-8 octet sequence</span><br><span class="line">      (hexadecimal)    |              (binary)</span><br><span class="line">   --------------------+---------------------------------------------</span><br><span class="line">   0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">   0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p>Given an array of integers representing the data, return whether it is a valid utf-8 encoding.  </p><p><strong>Note</strong>:<br>The input is an array of integers. Only the <strong>least significant 8 bits</strong> of each integer is used to store the data. This means each integer represents only 1 byte of data.</p><h4 id="Example1"><a href="#Example1" class="headerlink" title="Example1:"></a>Example1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.</span><br><span class="line"></span><br><span class="line">Return true.</span><br><span class="line">It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.</span><br></pre></td></tr></table></figure><h4 id="Example2"><a href="#Example2" class="headerlink" title="Example2:"></a>Example2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.</span><br><span class="line"></span><br><span class="line">Return false.</span><br><span class="line">The first 3 bits are all one&apos;s and the 4th bit is 0 means it is a 3-bytes character.</span><br><span class="line">The next byte is a continuation byte which starts with 10 and that&apos;s correct.</span><br><span class="line">But the second continuation byte does not start with 10, so it is invalid.</span><br></pre></td></tr></table></figure><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>UTF-8 中的一个字符可能的长度为 <strong>1 到 4</strong> 字节，遵循以下的规则：</p><ul><li>对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。</li><li>对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</li></ul><p><strong>这是 UTF-8 编码的工作方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Char. number range  |        UTF-8 octet sequence</span><br><span class="line">     (hexadecimal)    |              (binary)</span><br><span class="line">  --------------------+---------------------------------------------</span><br><span class="line">  0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">  0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">  0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">  0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p>给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。   </p><p><strong>说明</strong>：<br>输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。</p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.</span><br><span class="line"></span><br><span class="line">返回 true 。</span><br><span class="line">这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。</span><br></pre></td></tr></table></figure><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.</span><br><span class="line"></span><br><span class="line">返回 false 。</span><br><span class="line">前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。</span><br><span class="line">下一个字节是开头为 10 的延续字节，这是正确的。</span><br><span class="line">但第二个延续字节不以 10 开头，所以是不符合规则的。</span><br></pre></td></tr></table></figure><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><blockquote><p>一开始我理解出现错误认为只有一个utf-8编码让你判断，其实是判断一组连续的编码序列，也就是若干个utf-8序列。  </p></blockquote><p>不用位运算的方法，也就是将每个数据通过Integer.toBinaryString(data).toCharArray来判断。   </p><p>更简洁的做法是直接通过位运算来记录1的位数，过程如下:  </p><ol><li>data&gt;&gt;5==0b110 右移5位如果是0b110说明有2个字节，还有1个字节需要额外判断<br>（ 或者data &amp; 0b11000000==0b11000000,与上述功能一致  ）</li><li>data&gt;&gt;4==0b1110 右移4位如果是0b1110说明有3个字节，还有2个字节需要额外判断</li><li>data&gt;&gt;3==0b11110 右移3位如果是0b110说明有4个字节，还有3个字节需要额外判断</li><li>data&gt;&gt;7=0b1表示字符为10000000情况直接返回false  </li><li>如果bitSize==1，表示当前为utf—8编码的第一个字符，做以上判断</li><li>如果bitSize!=1，表示当前正在判断10开头的字符，如果data[i]&gt;&gt;6!=0b10，直接返回false</li></ol><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validUtf8</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitSize=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bitSize==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(data[i]&gt;&gt;<span class="number">5</span>==<span class="number">0b110</span>) bitSize=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(data[i]&gt;&gt;<span class="number">4</span>==<span class="number">0b1110</span>) bitSize=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(data[i]&gt;&gt;<span class="number">3</span>==<span class="number">0b11110</span>) bitSize=<span class="number">4</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(data[i]&gt;&gt;<span class="number">7</span>==<span class="number">0b1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//10000000情况</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(data[i]&gt;&gt;<span class="number">6</span>!=<span class="number">0b10</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                bitSize--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bitSize==<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 363】Max Sum of Rectangle No Larger Than K</title>
      <link href="/2018/05/25/%5BLeetCode%20363%5D%20Max%20Sum%20of%20Rectangle%20No%20Larger%20Than%20K%20/"/>
      <url>/2018/05/25/%5BLeetCode%20363%5D%20Max%20Sum%20of%20Rectangle%20No%20Larger%20Than%20K%20/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-363-Max-Sum-of-Rectangle-No-Larger-Than-K"><a href="#LeetCode-363-Max-Sum-of-Rectangle-No-Larger-Than-K" class="headerlink" title="[LeetCode 363] Max Sum of Rectangle No Larger Than K"></a>[LeetCode 363] Max Sum of Rectangle No Larger Than K</h1><h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k.</p><p><strong>Note</strong>:<br>The input is an array of integers. Only the <strong>least significant 8 bits</strong> of each integer is used to store the data. This means each integer represents only 1 byte of data.</p><h4 id="Example1"><a href="#Example1" class="headerlink" title="Example1:"></a>Example1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given matrix = [</span><br><span class="line">  [1,  0, 1],</span><br><span class="line">  [0, -2, 3]</span><br><span class="line">]</span><br><span class="line">k = 2</span><br></pre></td></tr></table></figure><p>The answer is <strong>2</strong>. Because the sum of rectangle <strong>[[0, 1], [-2, 3]]</strong> is 2 and 2 is the max number no larger than k (k = 2).</p><h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><ol><li>The rectangle inside the matrix must have an area &gt; 0.</li><li>What if the number of rows is much larger than the number of columns?  </li></ol><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>给定一个非空的二位矩阵和一个整数K，找到矩阵中子矩阵和最大并且不超过k的最大值。</p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定矩阵 matrix = [</span><br><span class="line">  [1,  0, 1],</span><br><span class="line">  [0, -2, 3]</span><br><span class="line">]</span><br><span class="line">k = 2</span><br></pre></td></tr></table></figure><p>答案是<strong>2</strong>，因为矩形<strong>[[0, 1], [-2, 3]]</strong>和是2并且2 是不超过k（k=2）的最大值 。</p><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h4><blockquote><p>这道题用纯暴力只能过95%左右，后面几个用例都会超时，所以在暴力的基础上稍微改进一下即可通过。（但不是最优解，复杂度为O(N<sup>2</sup>M<sup>2</sup>)）</p></blockquote><p> 用一个新矩阵保存计算值，每个值表示从点（0,0）到（i,j）的和，则计算（x1,y1）到（x2,y2）的值有以下四种情况：  </p><ul><li>x1-1&lt;0 &amp;&amp; y1-1&lt;0: 说明（x1,y1）即为（0,0）点，直接返回存储矩阵中s[x2][y2]的值</li><li><p>x1-1&gt;=0 &amp;&amp; y1-1&lt;0: 说明y1=0，  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">-------</span><br><span class="line">5 6 7 8</span><br><span class="line">0 1 2 9</span><br><span class="line">-------</span><br><span class="line">计算从（1,0）到（3，3）的值</span><br></pre></td></tr></table></figure><p>则返回s[x2][y2]-s[x1-1][y2]</p></li></ul><ul><li><p>x1-1<0 &&="" y1-1="">=0: 说明x1=0，  </0></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1|2 3 4|</span><br><span class="line">5|6 7 8|</span><br><span class="line">0|1 2 9|</span><br><span class="line"></span><br><span class="line">计算从（0,1）到（3，3）的值</span><br></pre></td></tr></table></figure></li></ul><p>则返回s[x2][y2]-s[x2][y1-1]  </p><ul><li><p>x1-1&gt;=0 &amp;&amp; y1-1&gt;=0:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line"> -------</span><br><span class="line">5|6 7 8|</span><br><span class="line">0|1 2 9|</span><br><span class="line"> -------</span><br></pre></td></tr></table></figure></li></ul><p>则返回s[x2][y2]-(s[x1-1][y2]+s[x2][y1-1]-s[x1-1][y1-1])  </p><blockquote><p>遍历子矩阵用四层循环即可解决。  </p></blockquote><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [][]store=<span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                store[i][j]=sum(matrix,<span class="number">0</span>,<span class="number">0</span>,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;row;x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;col;y++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;row;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;col;j++)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> t=sSum(store,x,y,i,j);</span><br><span class="line">                    <span class="keyword">if</span>(t==k)</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    <span class="keyword">if</span>(flag &amp;&amp; t&lt;k)&#123;</span><br><span class="line">                        max=t;</span><br><span class="line">                        flag=<span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(t&lt;k)&#123;</span><br><span class="line">                    max=Math.max(t,max);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sSum</span><span class="params">(<span class="keyword">int</span> [][]s,<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2 )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x1-<span class="number">1</span>&lt;<span class="number">0</span> &amp;&amp; y1-<span class="number">1</span>&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s[x2][y2];</span><br><span class="line">        <span class="keyword">if</span>(x1-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; y1-<span class="number">1</span>&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s[x2][y2]-s[x1-<span class="number">1</span>][y2];</span><br><span class="line">        <span class="keyword">if</span>(x1-<span class="number">1</span>&lt;<span class="number">0</span> &amp;&amp; y1-<span class="number">1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s[x2][y2]-s[x2][y1-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s[x2][y2]-(s[x1-<span class="number">1</span>][y2]+s[x2][y1-<span class="number">1</span>]-s[x1-<span class="number">1</span>][y1-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> [][]matrix,<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x1;i&lt;=x2;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=y1;j&lt;=y2;j++)&#123;  </span><br><span class="line">                res+=matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Solution2-动态递归解法（学习后补充）"><a href="#Solution2-动态递归解法（学习后补充）" class="headerlink" title="Solution2:动态递归解法（学习后补充）"></a>Solution2:动态递归解法（学习后补充）</h4><p>首先使用动态规划解法，这道题目可以拆分成两道题。<br>第一点是求矩阵子矩阵最大和的动态规划思想，<a href="https://www.youtube.com/watch?v=yCQN096CwWM" target="_blank" rel="noopener">参考视频链接</a>。<br><img src="/img/matrix.png" alt="">  </p><p>具体思想就是，按列扫描累加每一列然后求最大值，这样就转换为一维数组子数组求最大和的问题，这是一个简单的动态规划，dp[i]=max(dp[i-1],array[i]);  </p><p>第二点就是一维数组子数组最大和有可能大于给定的k，所以问题转换为求一维数组子数组和不大于k的最大值：  </p><blockquote><p>通过累加和可以求得任意区间的和，例如，cum数组为累加和数组，cum[i]表示从cum[0]到cum[i]的和，则区间（i,j）的和可表示为cum[j]-cum[i-1];  </p></blockquote><p>这里还要借助TreeSet因为treeset中ceiling方法可以求出大于或等于给定的元素的最小元素，也就是说我们在累加过程中去比较max和set.ceiling(sum-k)的大小即可，由于treeset查询这一步时间复杂度是O(logn),所以总的时间复杂度是O(N2*M*log(M)),如果列数远远大于行数，可以按照行扫描。  </p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rowSize=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> colSize=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> maxSum=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> currentSum=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// int maxLeft=0;</span></span><br><span class="line">       <span class="comment">// int maxRight=0;</span></span><br><span class="line">       <span class="comment">//  int maxUp=0;</span></span><br><span class="line">       <span class="comment">//  int maxDown=0;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> []rowArray=<span class="keyword">new</span> <span class="keyword">int</span>[rowSize];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>;left&lt;colSize;left++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> right=left;right&lt;colSize;right++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowSize;i++)&#123;</span><br><span class="line">                    rowArray[i]+=matrix[i][right];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                currentSum=maxSubArray(rowArray,k);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(currentSum==k)</span><br><span class="line">                    <span class="keyword">return</span> k;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(currentSum&lt;k)</span><br><span class="line">                    maxSum=Math.max(currentSum,maxSum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowSize;i++)&#123;</span><br><span class="line">                    rowArray[i]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">       TreeSet&lt;Integer&gt; set=<span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">        set.add(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">           sum+=a[i];</span><br><span class="line">           Integer v=set.ceiling(sum-k);<span class="comment">//返回大于或等于给定的元素的最小元素，或null</span></span><br><span class="line">           <span class="keyword">if</span>(v!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               max=Math.max(sum-v,max);</span><br><span class="line">           &#125;</span><br><span class="line">           set.add(sum);</span><br><span class="line">           </span><br><span class="line">       &#125; </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 78】Subsets 子集</title>
      <link href="/2018/05/24/%5BLeetCode%2078%5DSubsets%20%E5%AD%90%E9%9B%86/"/>
      <url>/2018/05/24/%5BLeetCode%2078%5DSubsets%20%E5%AD%90%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-78-Subsets-子集"><a href="#LeetCode-78-Subsets-子集" class="headerlink" title="[LeetCode 78]Subsets 子集"></a>[LeetCode 78]Subsets 子集</h1><h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a set of <strong>distinct</strong> integers, nums, return all possible subsets (the power set).</p><p><strong>Note</strong>: The solution set must not contain duplicate subsets.  </p><h4 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p><strong>说明</strong>：解集不能包含重复的子集。  </p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p><strong>Solution 1</strong>: 一个集合有n个元素，则其有2<sup>n</sup>的子集。  </p><p>列出从0到2<sup>n</sup>-1的所有二进制，0表示不取对应元素，1表示取对应元素，即可得出所有子集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">123Subset</span><br><span class="line">0000[]</span><br><span class="line">10013</span><br><span class="line">20102</span><br><span class="line">301123</span><br><span class="line">41001</span><br><span class="line">510113</span><br><span class="line">611012</span><br><span class="line">7111123</span><br></pre></td></tr></table></figure><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count=pow(<span class="number">2</span>,nums.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> []bit=Integer.toBinaryString(i).toCharArray();</span><br><span class="line">            ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">//从数组最后一位开始判断</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=bit.length-<span class="number">1</span>,k=nums.length-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--,k--)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(bit[j]==<span class="string">'1'</span>)</span><br><span class="line">                 temp.add(nums[k]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(temp);</span><br><span class="line">            res.add(temp);</span><br><span class="line">           temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            res*=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Solution 2</strong>：<br>深度优先算法，由于原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况，所以可以构造一棵二叉树，左子树表示选择该元素，右子树表示不选择，最终的叶节点就是所有子集合，树的结构如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     []        </span><br><span class="line">                 /          \        </span><br><span class="line">                /            \     </span><br><span class="line">               /              \</span><br><span class="line">            [1]                []</span><br><span class="line">         /       \           /    \</span><br><span class="line">        /         \         /      \        </span><br><span class="line">     [1 2]       [1]       [2]     []</span><br><span class="line">    /     \     /   \     /   \    / \</span><br><span class="line">[1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []</span><br></pre></td></tr></table></figure><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        getSubList(nums,res,temp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSubList</span><span class="params">(<span class="keyword">int</span> []nums,List&lt;List&lt;Integer&gt;&gt; res,ArrayList&lt;Integer&gt; temp,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(temp));<span class="comment">//注意要new一个ArrayList对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;nums.length;i++)&#123;</span><br><span class="line">            temp.add(nums[i]);<span class="comment">//选择元素nums[i]</span></span><br><span class="line">            getSubList(nums,res,temp,i+<span class="number">1</span>);<span class="comment">//下一个元素</span></span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);<span class="comment">//不选择nums[i]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 48】Rotate Image 旋转图像</title>
      <link href="/2018/05/24/%5BLeetCode%2048%5DRotate%20Image%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
      <url>/2018/05/24/%5BLeetCode%2048%5DRotate%20Image%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-48-Rotate-Image-旋转图像"><a href="#LeetCode-48-Rotate-Image-旋转图像" class="headerlink" title="[LeetCode 48]Rotate Image 旋转图像"></a>[LeetCode 48]Rotate Image 旋转图像</h1><h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given an n x n 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise).</p><h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.  </p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h4><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。  </p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p>将矩阵沿着主对角线翻转一次，再沿着对称线旋转一次即可。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//沿着主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[j][i];</span><br><span class="line">                matrix[j][i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//沿着对称轴线翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[i][n-j-<span class="number">1</span>];</span><br><span class="line">                matrix[i][n-j-<span class="number">1</span>]=temp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【LeetCode 01】 Two Sum 两数之和</title>
      <link href="/2018/05/24/%5BLeetCode%2001%5DTwo%20Sum%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2018/05/24/%5BLeetCode%2001%5DTwo%20Sum%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-01-Two-Sum-两数之和"><a href="#LeetCode-01-Two-Sum-两数之和" class="headerlink" title="[LeetCode 01]Two Sum 两数之和"></a>[LeetCode 01]Two Sum 两数之和</h1><h4 id="Problem-decription"><a href="#Problem-decription" class="headerlink" title="Problem decription:"></a>Problem decription:</h4><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.  </p><h4 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。  </p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h4 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h4><ul><li>排序数组，用两个头尾指针遍历即可，排序复杂度为O(nlogn),空间复杂度为O(1)；</li><li><p>利用map，以&lt;值,数组下标&gt;方式储存，再遍历数组即可；  </p><p>这里采用第二种解法，要注意考虑数组中包含重复值的情况，在加入map的过程中要做判断；    </p></li></ul><h4 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; h=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> []result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h.containsKey(nums[i]) &amp;&amp; <span class="number">2</span>*nums[i]==target)&#123;</span><br><span class="line">                result[<span class="number">0</span>]=h.get(nums[i]);</span><br><span class="line">                result[<span class="number">1</span>]=i;</span><br><span class="line">                flag=<span class="keyword">false</span>;<span class="comment">// 如果在加入时的重复值即为结果，则后面无需执行</span></span><br><span class="line">            &#125;</span><br><span class="line">            h.put(nums[i],i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h.containsKey(target-nums[j]) &amp;&amp; target-nums[j]!=nums[j] &amp;&amp; flag)&#123;</span><br><span class="line">                result[<span class="number">0</span>]=j;</span><br><span class="line">                result[<span class="number">1</span>]=h.get(target-nums[j]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MarkDown基本语法</title>
      <link href="/2018/05/22/MarkDown%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/05/22/MarkDown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>为了顺畅的在github pages上书写自己的blog，需要学习一些基本的MarkDown语法。</p><h2 id="常用语法规则"><a href="#常用语法规则" class="headerlink" title="常用语法规则"></a>常用语法规则</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。快捷键：command + 1/2/3/4/5/6</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>只需在行末加两个空格键和一个回车键即可换行。快捷键：control + 回车键</p><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加粗 - 快捷键：command + B   </span><br><span class="line">斜体 - 快捷键：command + I  </span><br><span class="line">删除线 - 快捷键：command + U  </span><br><span class="line">底纹  - 快捷键：command + K  </span><br><span class="line">下划线 - html：&lt;u&gt;text&lt;/u&gt;</span><br><span class="line">分割线 - 用***</span><br></pre></td></tr></table></figure><p><strong> 加粗 </strong> : <strong>hello</strong><br>* 斜体 *  :<em>hello</em><br>~~ 删除线 ~~  :<del>hello</del><br>` 底纹 `  :<code>hello</code><br>分割线：</p><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. <u><strong>符号要和文字之间加上一个字符的空格</strong></u>。  </p><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><ul><li>a</li><li>b</li><li>c  </li></ul><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><ol><li>a</li><li>b</li><li>c</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可</p><blockquote><p>this is a quote</p></blockquote><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>图片为：<code>![]()</code></p><p>链接为：<code>[]()</code>  </p><h5 id="在线插入："><a href="#在线插入：" class="headerlink" title="在线插入："></a>在线插入：</h5><p>插入图片的地址需要图床，这里推荐<a href="http://weibotuchuang.sinaapp.com/" target="_blank" rel="noopener">围脖图床修复计划</a>，生成URL  </p><h5 id="本地插入："><a href="#本地插入：" class="headerlink" title="本地插入："></a>本地插入：</h5><p><code>![](本地路径)</code>  </p><h5 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h5><p><img src="/img/1.png" alt="icon">  </p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>使用三个`包裹代码即可 ,注意后面不要跟空格，hexo在生成网页时代码块之间匹配会出现问题 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用github pages + hexo搭建博客</title>
      <link href="/2018/05/22/%E4%BD%BF%E7%94%A8github%20pages%20+%20hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/05/22/%E4%BD%BF%E7%94%A8github%20pages%20+%20hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p><br><blockquote class="blockquote-center"><p><em>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</em>  </p></blockquote></p><blockquote><p>目前比较热门的两种方式就是使用静态博客框架 jekyll 或者 hexo，相对于jekyll，hexo主题丰富，第三方插件优秀，配置简单，最主要的一点，hexo的开发文档阅读感受较jekyll来说更舒服。</p></blockquote><h3 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="一.环境搭建"></a>一.环境搭建</h3><blockquote><p>官方文档非常详细 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo documents</a>  </p></blockquote><p> <em>这里以MacOs为例</em></p><ul><li><p>github账号<br><a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">注册地址</a>  </p></li><li><p>安装<strong>Node.js</strong>  </p><p>  cURL:<br><code>$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</code></p><p>  Wget:<br><code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</code></p><p>  安装完成后重启终端：<br><code>$ nvm install stable</code>  </p><p>  这里推荐下载<a href="https://nodejs.org/en/" target="_blank" rel="noopener">安装程序</a>来安装</p></li><li>安装<strong>git</strong><br><code>$ brew install git</code>  </li><li>安装 Hexo<br><code>$ npm install -g hexo-cli</code>   </li></ul><h3 id="二-建站"><a href="#二-建站" class="headerlink" title="二.建站"></a>二.建站</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folderName&gt;</span><br><span class="line">$ cd &lt;folderName&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>安装完成后文件目录结构如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">├── \_config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── \_drafts</span><br><span class="line">|   └── \_posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>你可以在_config.yml中配置大部分网站设置。  </p><p>其他一些Hexo常用命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hexo n          # 新建文章，在\source\_posts文件夹里</span><br><span class="line">hexo new page   # 新建页面，比如想在导航栏新增一个“关于我”的页面</span><br><span class="line">hexo clean      # 清除本地的数据库和生成的public文件夹</span><br><span class="line">hexo g          # 生成博客文件</span><br><span class="line">hexo s          # 运行在本地浏览器，可当预览使用</span><br><span class="line">hexo d          # 部署博客到Github等</span><br></pre></td></tr></table></figure><h3 id="三-创建Repo"><a href="#三-创建Repo" class="headerlink" title="三.创建Repo"></a>三.创建Repo</h3><ul><li><p>新建一个repo，注意名称一定是your_username.github.io这样的格式。</p></li><li><p>进入刚新建的仓库，点击Setting，一直拖到最下面，选择Automatic Page Generator，随便选个主题然后发布即可。</p></li><li><p>在站点_config.yml文件中任意位置添加以下代码段：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  # 填上你自己的仓库名，注意后面有`.git`</span><br><span class="line">  repository: git@github.com:your_username/your_username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><em>注意每个：后面都要跟一个空格！</em></p><ul><li>安装部署所需：<br><code>$ npm install hexo-deployer-git --save</code></li></ul><h3 id="四-主题"><a href="#四-主题" class="headerlink" title="四.主题"></a>四.主题</h3><blockquote><p>创建 Hexo 主题非常容易，您只要在 themes 文件夹内，新增一个任意名称的文件夹，并修改 _config.yml 内的 theme 设定，即可切换主题。一个主题可能会有以下的结构：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── \_config.yml(配置是无需重启服务器会自动更新)</span><br><span class="line">├── languages</span><br><span class="line">├── layout</span><br><span class="line">├── scripts</span><br><span class="line">└── source</span><br></pre></td></tr></table></figure><p>这里推荐使用最多的<em><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">nexT</a></em> 主题</p><h3 id="五-新建页面"><a href="#五-新建页面" class="headerlink" title="五.新建页面"></a>五.新建页面</h3><h5 id="新建分类页面："><a href="#新建分类页面：" class="headerlink" title="新建分类页面："></a>新建分类页面：</h5><pre><code>hexo new page categories</code></pre><p>打开<code>../source/categories/index.md</code>  </p><p>编辑相对应的type</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-05-21 22:00:35</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在站点_config.yml中更改menu下代码，如果没有添加  </p><p>  categories: /categories/  </p><h4 id="新建导航"><a href="#新建导航" class="headerlink" title="新建导航"></a>新建导航</h4><p>默认导航栏只有首页、归档、标签、分类四项。如果想增加其他如C++、随笔等。需要打开\themes\next_config.yml找到如下  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)</span><br><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  categories: /categories</span><br><span class="line">  tags: /tags</span><br><span class="line">  archives: /archives</span><br><span class="line">  #这里是新增的，Coding是一级目录，C是二级目录，同理随笔是一级目录</span><br><span class="line">  c++: /categories/Coding/C/</span><br><span class="line">  python: /categories/Coding/Python/</span><br><span class="line">  essay: /categories/随笔/</span><br><span class="line">  #注意这里没有/categories</span><br><span class="line">  about: /about</span><br></pre></td></tr></table></figure><hr><p><strong><em>that‘s all！</em></strong></p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
            <tag> github pages </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
