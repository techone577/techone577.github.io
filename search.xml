<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Leetcode47】Permutations II 全排列 II]]></title>
    <url>%2F2018%2F10%2F14%2F%5BLeetcode47%5D%20Permutations%20II%20%E5%85%A8%E6%8E%92%E5%88%97%20II%2F</url>
    <content type="text"><![CDATA[[Leetcode47] Permutations II 全排列 II“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 给定一个可包含重复数字的序列，返回所有不重复的全排列。 * 示例: * 输入: [1,1,2] * 输出: * [ * [1,1,2], * [1,2,1], * [2,1,1] * ] */public class leetcode47 &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique (int[] nums) &#123; int[] isVisited = new int[nums.length]; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); helper(res, new ArrayList&lt;&gt;(), 0, nums, isVisited); Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;(); for(List&lt;Integer&gt; list:res) set.add(list); res = new ArrayList&lt;&gt;(); res.addAll(set); return res; &#125; public void helper (List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; bag, int pos, int[] nums, int[] isVisited) &#123; if (pos == nums.length) res.add(new ArrayList&lt;&gt;(bag)); for (int i = 0; i &lt; nums.length; ++i) &#123; if (isVisited[i] != 1) &#123; bag.add(nums[i]); isVisited[i] = 1; helper(res, bag, pos + 1, nums, isVisited); isVisited[i] = 0; bag.remove(bag.size() - 1); &#125; &#125; &#125; public static void main (String[] args) &#123; int[] nums = new int[]&#123;1, 1, 2&#125;; new leetcode47().permuteUnique(nums); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode25】Reverse Nodes in k-Group k个一组翻转链表]]></title>
    <url>%2F2018%2F10%2F14%2F%5BLeetcode25%5D%20%20Reverse%20Nodes%20in%20k-Group%20k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[Leetcode25] Reverse Nodes in k-Group k个一组翻转链表“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 * k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 * 示例 : * 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 * 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 * 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 * 说明 : * 你的算法只能使用常数的额外空间。 * 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 */public class leetcode25 &#123; // 1 2 3 4 5// 2 1 4 3 5 public ListNode reverseKGroup (ListNode head, int k) &#123; int length = 0; ListNode temp = head; while (temp != null) &#123; ++length; temp = temp.next; &#125; int count = length / k; ListNode current = head, pre = head, post = head, preTail = null, currentTail = head; for (int i = 0; i &lt; count; ++i) &#123; for (int j = 0; j &lt; k; ++j) &#123; if (j == 0) &#123; post = current.next; pre = current; currentTail = current; current = post; &#125; else &#123; post = current.next; current.next = pre; pre = current; current = post; &#125; &#125; if (preTail == null) &#123; preTail = currentTail; &#125; else &#123; preTail.next = pre; preTail = currentTail; &#125; if (i == 0) head = pre; &#125; if (preTail != null) preTail.next = current; return head; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode16】3Sum Closest 最接近的三数之和]]></title>
    <url>%2F2018%2F10%2F14%2F%5BLeetcode16%5D%203Sum%20Closest%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[Leetcode16] 3Sum Closest 最接近的三数之和“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021222324252627282930313233343536/** * 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 * * 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. * * 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). */public class leetcode16 &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int minMinus = Integer.MAX_VALUE,res =0; for(int i=0;i&lt;nums.length;++i)&#123; int j=i+1,k=nums.length-1; while(j&lt;k)&#123; int sum = nums[i] + nums[j] +nums[k]; if(sum == target) return target; if(sum &gt; target)&#123; if(sum - target &lt; minMinus) &#123; minMinus = sum - target; res = sum; &#125; --k; &#125; if(sum &lt; target)&#123; if( target - sum &lt; minMinus) &#123; minMinus = target - sum; res = sum; &#125; ++j; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode20】Longest Valid Parentheses 有效的括号]]></title>
    <url>%2F2018%2F10%2F14%2F%5BLeetcode20%5D%20Valid%20Parentheses%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[[Leetcode20] Valid Parentheses 有效的括号“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021222324252627282930/** * 给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串，判断字符串是否有效。 * 有效字符串需满足： * 左括号必须用相同类型的右括号闭合。 * 左括号必须以正确的顺序闭合。 * 注意空字符串可被认为是有效字符串。 */public class leetcode20 &#123; public boolean isValid (String s) &#123; if (("").equals(s)) return true; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (c == '(' || c == '[' || c == '&#123;') stack.push(c); else &#123; if (stack.isEmpty()) return false; Character peek = stack.peek(); String match = new StringBuilder().append(peek).append(c).toString(); if ("()".equals(match) || "[]".equals(match) || "&#123;&#125;".equals(match)) stack.pop(); else stack.push(c); &#125; &#125; return stack.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode14】Longest Common Prefix 最长公共前缀]]></title>
    <url>%2F2018%2F10%2F14%2F%5BLeetcode14%5D%20Longest%20Common%20Prefix%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[[Leetcode14] Longest Common Prefix 最长公共前缀“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 编写一个函数来查找字符串数组中的最长公共前缀。 * &lt;p&gt; * 如果不存在公共前缀，返回空字符串 ""。 * &lt;p&gt; * 示例 1: * &lt;p&gt; * 输入: ["flower","flow","flight"] * 输出: "fl" * 示例 2: * &lt;p&gt; * 输入: ["dog","racecar","car"] * 输出: "" * 解释: 输入不存在公共前缀。 */public class leetcode14 &#123; public String longestCommonPrefix (String[] strs) &#123; if (strs.length == 0) return ""; if (strs.length == 1) return strs[0]; int length = strs[0].length() &lt; strs[1].length() ? strs[0].length() : strs[1].length(); StringBuilder prefix = new StringBuilder(); for (int i = 0; i &lt;length;++i)&#123; if(strs[0].charAt(i) == strs[1].charAt(i)) prefix.append(strs[0].charAt(i)); else break; &#125; if(prefix.length() == 0) return ""; for(int i=2;i&lt;strs.length;++i)&#123; int l = prefix.length()&lt;strs[i].length()?prefix.length():strs[i].length(); for(int j=0;j&lt;l;++j)&#123; if(prefix.charAt(j)!=strs[i].charAt(j)) &#123; prefix = prefix.delete(j, prefix.length()); break; &#125; &#125; if(prefix.length()&gt;strs[i].length()) prefix = new StringBuilder(strs[i]); &#125; return prefix.toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode59】Spiral Matrix II 螺旋矩阵 II]]></title>
    <url>%2F2018%2F10%2F08%2F%5BLeetcode59%5D%20Spiral%20Matrix%20II%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20II%2F</url>
    <content type="text"><![CDATA[[Leetcode59] Spiral Matrix II 螺旋矩阵 II“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334/** * 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 */public class leetcode59 &#123; public int[][] generateMatrix(int n) &#123; int[][] res = new int[n][n]; int up = 0, down = n - 1, right = n - 1, left = 0; int num = 1; for (; ; ) &#123; for (int i = left; i &lt;= right; i++) &#123; res[up][i] = num++; &#125; if (++up &gt; down) break; for (int i = up; i &lt;= down; i++) &#123; res[i][right] = num++; &#125; if (--right &lt; left) break; for (int i = right; i &gt;= left; i--) &#123; res[down][i] = num++; &#125; if (--down &lt; up) break; for (int i = down; i &gt;= up; i--) res[i][left] = num++; if (++left &gt; right) break; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode4】Median of Two Sorted Arrays 两个排序数组的中位数]]></title>
    <url>%2F2018%2F10%2F08%2F%5BLeetcode4%5D%20Median%20of%20Two%20Sorted%20Arrays%20%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[Leetcode4] Median of Two Sorted Arrays 两个排序数组的中位数“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。 * 请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。 * 你可以假设 nums1 和 nums2 不同时为空。 * mergesort时间复杂度为O(m+n),O(log(m+n))学习后补充 */public class leetcode4 &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int n = nums1.length, m = nums2.length; int res = 0; int median = (n + m+1) / 2; boolean flag = true; if ((n + m) % 2 == 0) flag = false; int i = 0, j = 0, count = 0; while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] &lt; nums2[j]) &#123; res = nums1[i]; ++i; &#125; else &#123; res = nums2[j]; ++j; &#125; if (++count == median) &#123; if(flag == false) &#123; if( i&lt;nums1.length &amp;&amp; j&lt;nums2.length) &#123; res += nums1[i] &lt; nums2[j] ? nums1[i] : nums2[j]; &#125; else&#123; res+=i&lt;nums1.length?nums1[i]:nums2[j]; &#125; double ret = (double) res / 2; return ret; &#125; return res; &#125; &#125; while(i&lt;nums1.length)&#123; res = nums1[i]; ++i; if (++count == median) &#123; if(flag == false) &#123; res += nums1[i]; double ret = (double)res/2; return ret; &#125; return res; &#125; &#125; while(j&lt;nums2.length)&#123; res = nums2[j]; ++j; if (++count == median) &#123; if(flag == false) &#123; res += nums2[j]; double ret = (double)res/2; return ret; &#125; return res; &#125; &#125; return -1; &#125; public static void main(String []args)&#123; int []nums1 = new int[]&#123;1,2&#125;; int nums2[] = new int []&#123;3,4&#125;; System.out.println(new leetcode4().findMedianSortedArrays(nums1,nums2)); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode42】Trapping Rain Water 接雨水]]></title>
    <url>%2F2018%2F09%2F27%2F%5BLeetcode42%5D%20Trapping%20Rain%20Water%20%E6%8E%A5%E9%9B%A8%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[[Leetcode42] Trapping Rain Water 接雨水“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021222324252627282930313233343536/** * 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 * 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 * 示例: * 输入: [0,1,0,2,1,0,1,3,2,1,2,1] * 输出: 6 */public class leetcode42 &#123; public int trap (int[] height) &#123; if (height.length == 0) return 0; int maxHeight = 0, maxLeft = 0, maxRight = 0, maxIndex = 0; int res = 0; //用最长的高度分割两侧 for (int i = 0; i &lt; height.length; ++i) &#123; maxHeight = Math.max(maxHeight, height[i]); maxIndex = maxHeight == height[i] ? i : maxIndex; &#125; //左边计算 maxLeft = height[0]; for (int i = 0; i &lt;= maxIndex; ++i) &#123; if (maxLeft &gt; height[i]) res += maxLeft - height[i]; else maxLeft = height[i]; &#125; //右边计算 for (int i = height.length - 1; i &gt;= maxIndex; --i) &#123; if (maxRight &gt; height[i]) res += maxRight - height[i]; else maxRight = height[i]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode84】Largest Rectangle in Histogram 最大面积覆盖的矩阵]]></title>
    <url>%2F2018%2F09%2F27%2F%5BLeetcode84%5D%20Largest%20Rectangle%20in%20Histogram%20%20%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%E8%A6%86%E7%9B%96%E7%9A%84%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[[Leetcode84] Largest Rectangle in Histogram 最大面积覆盖的矩阵“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021222324252627/** * 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 * 求在该柱状图中，能够勾勒出来的矩形的最大面积。 * * 从中间向两端发散计算 */public class leetcode84 &#123; public int largestRectangleArea (int[] heights) &#123; int max = 0; for (int i = 0; i &lt; heights.length; ++i) &#123; int index = heights[i]; int l = i, r = i; while (l &gt;= 0 &amp;&amp; heights[l] &gt;= index) --l; while (r &lt; heights.length &amp;&amp; heights[r] &gt;= index) ++r; int area = heights[i] * (r - l + 1-2); max = Math.max(area, max); &#125; return max; &#125; public static void main (String[] args) &#123; int[] nums = new int[]&#123;2, 1, 5, 6, 2, 3&#125;; new leetcode84().largestRectangleArea(nums); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode46】 Permutation 全排列]]></title>
    <url>%2F2018%2F09%2F27%2F%5BLeetcode46%5D%20Permutation%20%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[[Leetcode46] Permutation 全排列“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 `java/** 全排列*/public class leetcode46 { public List&lt;List&gt; permute (int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); helper(res, nums, 0); return res; } private void helper (List&lt;List&gt; res, int[] nums, int pos) { if (pos == nums.length) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int t : nums) { list.add(t); } res.add(list); } for (int i = pos; i &lt; nums.length; i++) { swap(nums, pos, i); helper(res, nums, pos + 1); swap(nums, pos, i); } } private void swap (int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; }} `**]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode336】Palindrome Pairs 回文对]]></title>
    <url>%2F2018%2F09%2F27%2F%5BLeetcode336%5D%20Palindrome%20Pairs%20%20%E5%9B%9E%E6%96%87%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[[Leetcode336] Palindrome Pairs 回文对“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * 给定一组唯一的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。 * 示例 1: * 输入: ["abcd","dcba","lls","s","sssll"] * 输出: [[0,1],[1,0],[3,2],[2,4]] * 解释: 可拼接成的回文串为 ["dcbaabcd","abcddcba","slls","llssssll"] * 示例 2: * 输入: ["bat","tab","cat"] * 输出: [[0,1],[1,0]] * 解释: 可拼接成的回文串为 ["battab","tabbat"] * * 思路： * 1、将字符串反转后和字符串下标放入map中 * 2、遍历words数组，对每个字符串遍历即str = ls + rs * 3、如果ls是回文串，判断rs是否在map中，如果在，则 sr+ls+rs(map中存的是sr的反转序列)，则（map中的下标，当前字符串下标）为一组结果 * 4、如果rs是回文串，判断ls是否在map中，如果在，则 ls+rs+sl 是反转序列，则（当前字符串下标，map中的下标）为一组结果 * 5、对于空字符串""单独判断，如果words中字符串是回文串，则将下标保存到list，（空字符串下标，list中保存的下标） */public class leetcode336 &#123; //TLE超时 public List&lt;List&lt;Integer&gt;&gt; palindromePairs (String[] words) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; words.length; i++) &#123; for (int j = i + 1; j &lt; words.length; j++) &#123; StringBuilder s1 = new StringBuilder().append(words[i]).append(words[j]); StringBuilder s2 = new StringBuilder().append(words[j]).append(words[i]); if (s1.toString().equals(s1.reverse().toString())) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(i); list.add(j); res.add(list); &#125; if (s2.toString().equals(s2.reverse().toString())) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(j); list.add(i); res.add(list); &#125; &#125; &#125; return res; &#125; //AC public List&lt;List&lt;Integer&gt;&gt; solution (String[] words) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; words.length; i++) &#123; map.put(new StringBuilder(words[i]).reverse().toString(), i); &#125; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); boolean flag = false; List&lt;Integer&gt; palindromeList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; words.length; i++) &#123; for (int j = 0; j &lt; words[i].length(); j++) &#123; String ls = words[i].substring(0, j); String rs = words[i].substring(j, words[i].length()); if (j == 0 &amp;&amp; isPalindrome(rs)) palindromeList.add(i); if (isPalindrome(ls) &amp;&amp; map.containsKey(rs)) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (map.get(rs) != i) &#123; list.add(map.get(rs)); list.add(i); res.add(list); &#125; &#125; if (isPalindrome(rs) &amp;&amp; map.containsKey(ls)) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (map.get(ls) != i) &#123; list.add(i); list.add(map.get(ls)); res.add(list); &#125; &#125; &#125; //处理空字符串 if (words[i].equals("")) flag = true; &#125; if (flag) &#123; for (Integer t : palindromeList) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(map.get("")); list.add(t); res.add(list); &#125; &#125; return res; &#125; public static boolean isPalindrome (String str) &#123; return str.equals(new StringBuilder(str).reverse().toString()); &#125; public static void main (String[] args) &#123; String[] words = new String[]&#123;"a", ""&#125;; new leetcode336().solution(words); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode17】Letter Combinations of a Phone Number 电话号码的字母组合]]></title>
    <url>%2F2018%2F09%2F27%2F%5BLeetcode17%5D%20Letter%20Combinations%20of%20a%20Phone%20Number%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[[Leetcode17] Letter Combinations of a Phone Number 电话号码的字母组合“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 * 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 * 可以任意选择答案输出的顺序 * * dfs */public class leetcode17 &#123; private static Map&lt;Character, String&gt; map = new HashMap&lt;&gt;(); public List&lt;String&gt; letterCombinations (String digits) &#123; if (digits.length() == 0) return new ArrayList&lt;String&gt;(); map.put('2', "abc"); map.put('3', "def"); map.put('4', "ghi"); map.put('5', "jkl"); map.put('6', "mno"); map.put('7', "pqrs"); map.put('8', "tuv"); map.put('9', "wxyz"); List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(res, new String(), digits, 0); return res; &#125; private void helper (List&lt;String&gt; res, String bag, String digits, int pos) &#123; if (pos == digits.length()) &#123; res.add(bag); return; &#125; char digit = digits.charAt(pos); String letter = map.get(digit); for (int i = 0; i &lt; letter.length(); i++) &#123; helper(res, bag + letter.charAt(i), digits, pos + 1); &#125; &#125; public static void main (String[] args) &#123; new leetcode17().letterCombinations("23"); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637383940public class MergeSort &#123; /** * sort左边，sort右边，归并 */ public static void MergeSort (int[] nums, int l, int h) &#123; if (l &gt;= h) return; int left = l, right = h; int mid = (left + right) / 2; MergeSort(nums, left, mid); MergeSort(nums, mid + 1, right); Merge(nums, left, mid, right); &#125; /** *左边l-m，右边m+1 - h */ private static void Merge (int[] nums, int l, int m, int h) &#123; int newNums[] = new int[h - l + 1]; int i = l, j = m + 1, k = 0; while (i &lt;= m &amp;&amp; j &lt;= h) &#123; newNums[k++] = nums[i] &lt; nums[j] ? nums[i++] : nums[j++]; &#125; while (i &lt;= m) newNums[k++] = nums[i++]; while (j &lt;= h) newNums[k++] = nums[j++]; for (int p = 0; p &lt; newNums.length; p++) &#123; nums[p + l] = newNums[p]; &#125; &#125; public static void main (String[] args) &#123; int []nums = new int[] &#123;4,3,6,2,1,1,1,1,8,5,9,10,0&#125;; MergeSort(nums,0,nums.length-1); for(int t:nums) &#123; System.out.print(t+" "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode80】Remove Duplicates from Sorted Array II 删除数组中的重复项II]]></title>
    <url>%2F2018%2F09%2F27%2F%5BLeetcode80%5D%20Remove%20Duplicates%20from%20Sorted%20Array%20II%20%20%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II%2F</url>
    <content type="text"><![CDATA[[Leetcode80] Remove Duplicates from Sorted Array II 删除数组中的重复项II“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728/** * 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 * 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 * 示例 1: * 给定 nums = [1,1,1,2,2,3], * 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 * 你不需要考虑数组中超出新长度后面的元素。 * &lt;p&gt; * 注意是排好序的數組，所以比较前两个就好 */public class leetcode80 &#123; public int removeDuplicates (int[] nums) &#123; int index = 2; for (int i = 2; i &lt; nums.length; i++) &#123; if (nums[i] != nums[index - 2]) &#123; nums[index] = nums[i]; index++; &#125; &#125; return index; &#125; public static void main (String[] args) &#123; int[] nums = new int[]&#123;1, 1, 1, 2, 2, 2, 3, 3, 4&#125;; new leetcode80().removeDuplicates(nums); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class HeapSort &#123; public static void HeapSort (int[] nums) &#123; buildHeap(nums); for(int i=nums.length-1;i&gt;=0;i--)&#123; int temp = nums[0]; nums[0] = nums[i]; nums[i] = temp; maxHeapfy(nums,0,i); &#125; &#125; /** * 建堆，从下往上调整，从(n-1)/2-0，只有这些节点有子节点 */ private static void buildHeap (int[] nums) &#123; for (int i = ((nums.length - 1) - 1) / 2; i &gt;= 0; --i) &#123; maxHeapfy(nums,i,nums.length); &#125; &#125; //length排序时用来限定排好的位数 private static void maxHeapfy (int[] nums, int index,int length) &#123; for (; ; ) &#123; int max = index; int left = 2 * max + 1; int right = 2 * max + 2; //父节点、左孩子、右孩子选出最大 if (left &lt; length &amp;&amp; nums[left] &gt; nums[max]) max = left; if (right &lt; length &amp;&amp; nums[right] &gt; nums[max]) max = right; //交换并递归调整 if (max != index) &#123; int temp = nums[index]; nums[index] = nums[max]; nums[max] = temp; index = max; &#125; else break; &#125; &#125; public static void main (String[] args) &#123; int []nums = new int[] &#123;4,3,6,2,1,8,5,9,10,0&#125;; HeapSort(nums); for(int t:nums) &#123; System.out.print(t+" "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Leetcode80】Largest Rectangle in Histogram 最大面积覆盖的矩阵]]></title>
    <url>%2F2018%2F09%2F27%2F%5BLeetcode85%5D%20Largest%20Rectangle%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[[Leetcode85] Largest Rectangle 最大矩形“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 * 示例: * 输入: * [ * ['1','0','1','0','0'], * ['1','0','1','1','1'], * ['1','1','1','1','1'], * ['1','0','0','1','0'] * ] * 输出: 6 * * 将矩阵转换成一每一行为底的柱形图，以leetcode84方法求解 */public class leetcode85 &#123; public int maximalRectangle (char[][] matrix) &#123; if (matrix.length == 0) return 0; int column = matrix[0].length, row = matrix.length; int max = 0; int[][] numOfOne = new int[row][column]; for (int i = 0; i &lt; row; ++i) &#123; int[] heights = new int[column]; for (int j = 0; j &lt; column; ++j) &#123; if (matrix[i][j] == '0') numOfOne[i][j] = 0; else numOfOne[i][j] = i &gt; 0 ? numOfOne[i - 1][j] + 1 : 1; heights[j] = numOfOne[i][j]; &#125; max = Math.max(largestRectangleArea(heights), max); &#125; return max; &#125; public int largestRectangleArea (int[] heights) &#123; int max = 0; for (int i = 0; i &lt; heights.length; ++i) &#123; int index = heights[i]; int l = i, r = i; while (l &gt;= 0 &amp;&amp; heights[l] &gt;= index) --l; while (r &lt; heights.length &amp;&amp; heights[r] &gt;= index) ++r; int area = heights[i] * (r - l + 1 - 2); max = Math.max(area, max); &#125; return max; &#125; public static void main (String[] args) &#123; char[][] nums = new char[][]&#123; &#123;'1', '0', '1', '0', '0'&#125;, &#123;'1', '0', '1', '1', '1'&#125;, &#123;'1', '1', '1', '1', '1'&#125;, &#123;'1', '0', '0', '1', '0'&#125; &#125;; new leetcode85().maximalRectangle(nums); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 93】Restore IP Addresses 恢复IP地址]]></title>
    <url>%2F2018%2F09%2F13%2F%5BLeetCode%2093%5D%20Restore%20IP%20Addresses%20%E6%81%A2%E5%A4%8DIP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[[LeetCode 93] Restore IP Addresses 恢复IP地址“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 * 示例: * 输入: "25525511135" * 输出: ["255.255.11.135", "255.255.111.35"] */public class leetcode93 &#123; public List&lt;String&gt; restoreIpAddresses (String s) &#123; StringBuilder str = new StringBuilder(s); List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(s.length()&lt;4 || s.length()&gt;12) return res; helper(res, s, new String(), 0, 1); return res; &#125; private void helper (List&lt;String&gt; res, String s, String str, int pos, int depth) &#123; if (depth &gt; 3) &#123; //插入四个即为终止条件 String seg = s.substring(pos); if (isValid(seg)) &#123; str = str + seg; res.add(str); &#125; return; &#125; //有效位只能为3位以内 for (int i = 1; i &lt;= 3 &amp;&amp; pos + i &lt; s.length(); i++) &#123; //important String seg = s.substring(pos, pos + i); if (isValid(seg)) &#123; helper(res, s, str + seg + ".", pos + i, depth + 1); &#125; &#125; &#125; private boolean isValid (String seg) &#123; if(seg.charAt(0) == '0' &amp;&amp; seg.length()&gt;1) return false; int ipNum = Integer.valueOf(seg); if (0 &lt;= ipNum &amp;&amp; ipNum &lt;= 255) return true; return false; &#125; public static void main (String[] args) &#123; new leetcode93().restoreIpAddresses("010010"); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 75】 Sort Colors 排序颜色]]></title>
    <url>%2F2018%2F09%2F13%2F%5BLeetCode%2075%5D%20Sort%20Colors%20%E6%8E%92%E5%BA%8F%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[[LeetCode 75] Sort Colors 排序颜色“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 1234567891011121314151617181920212223242526272829303132/** * 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 * 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 * 注意: * 不能使用代码库中的排序函数来解决这道题。 * * 遇到0放到左边，2放到右边，1跳过 */public class leetcode75 &#123; public void sortColors (int[] nums) &#123; int pre = 0; int post = nums.length - 1; for (int i = 0; i &lt;= post; i++) &#123; if (nums[i] == 0) &#123; int t = nums[pre]; nums[pre] = nums[i]; nums[i] = t; ++pre; &#125; else if (nums[i] == 2) &#123; int t = nums[post]; nums[post] = nums[i]; nums[i] = t; --i; --post; &#125; &#125; &#125; public static void main (String[] args) &#123; new leetcode75().sortColors(new int[]&#123;1,2,2,1,1,0,0,2,0,0,1,0,0,1,0&#125;); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 73】Set Matrix Zeroes 矩阵置零]]></title>
    <url>%2F2018%2F09%2F13%2F%5BLeetCode%2073%5DSet%20Matrix%20Zeroes%20%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 [LeetCode 73]Set Matrix Zeroes 矩阵置零1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 * * 用第一行第一列记录每一行每一列的信息，用两个int记录第一行第一列的信息 */public class leetcode73 &#123; public void setZeroes (int[][] matrix) &#123; int row0Flag = 1, colum0Flag = 1; for (int i = 0; i &lt; matrix[0].length; i++) &#123; if (matrix[0][i] == 0) &#123; row0Flag = 0; break; &#125; &#125; for (int i = 0; i &lt; matrix.length; i++) &#123; if (matrix[i][0] == 0) &#123; colum0Flag = 0; break; &#125; &#125; for (int i = 1; i &lt; matrix[0].length; i++) &#123; for (int j = 0; j &lt; matrix.length; ++j) &#123; if (matrix[i][j] == 0) &#123; matrix[0][i] = 0; break; &#125; &#125; &#125; for (int i = 1; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; ++j) &#123; if (matrix[i][j] == 0) &#123; matrix[i][0] = 0; break; &#125; &#125; &#125; for (int i = 0; i &lt; matrix[0].length; ++i) &#123; if (matrix[0][i] == 0) &#123; for (int j = 0; j &lt; matrix.length; ++j) &#123; matrix[i][j] = 0; &#125; &#125; &#125; for (int i = 0; i &lt; matrix.length; ++i) &#123; if (matrix[i][0] == 0) &#123; for (int j = 0; j &lt; matrix[0].length; ++j) &#123; matrix[i][j] = 0; &#125; &#125; &#125; if (row0Flag == 0) &#123; for (int i = 0; i &lt; matrix[0].length; ++i) &#123; matrix[0][i] = 0; &#125; &#125; if (colum0Flag == 0) &#123; for (int i = 0; i &lt; matrix.length; ++i) &#123; matrix[i][0] = 0; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 79】 Word Search 单词搜素]]></title>
    <url>%2F2018%2F09%2F13%2F%5BLeetCode%2079%5D%20Word%20Search%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[[LeetCode 79] Word Search 单词搜素“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 * 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 */public class leetcode79 &#123; public boolean exist (char[][] board, String word) &#123; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] == word.charAt(0)) &#123; if (helper(board, word, i, j, 0)) return true; &#125; &#125; &#125; return false; &#125; private boolean helper (char[][] board, String word, int i, int j, int pos) &#123; if (pos == word.length()) return true; if (i &gt;= board.length || j &gt;= board[0].length || i &lt; 0 || j &lt; 0) return false; if (word.charAt(pos) != board[i][j]) return false; boolean res = false; char temp = board[i][j]; //表示已经访问不能再次访问 board[i][j] = '*'; res = helper(board, word, i - 1, j, pos + 1) || helper(board, word, i + 1, j, pos + 1) || helper(board, word, i, j - 1, pos + 1) || helper(board, word, i, j + 1, pos + 1); //恢复未访问状态 board[i][j] = temp; return res; &#125; public static void main (String []args) &#123; char [][]a= new char [][]&#123;&#123;'C','A','A'&#125;, &#123;'A','A','A'&#125;, &#123;'B','C','D'&#125;&#125;; new leetcode79().exist(a,"AAB"); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用LinkedHashMap实现LRU算法]]></title>
    <url>%2F2018%2F09%2F13%2F%E5%88%A9%E7%94%A8LinkedHashMap%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[利用LinkedHashMap实现LRU算法“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class LRU &#123; public static void lruByLinkedHashMap () &#123; LinkedHashMap&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;Integer, Integer&gt;(20, (float) 0.75, true) &#123; @Override protected boolean removeEldestEntry (Map.Entry&lt;Integer, Integer&gt; eldest) &#123; return size() &gt; 10; &#125; &#125;; for (int i = 0; i &lt; 10; i++) &#123; map.put(i, i); &#125; System.out.println(map.toString()); map.get(1); System.out.println("访问元素1后: " + map.toString()); map.put(11, 11); System.out.println("添加元素11后: " + map.toString()); &#125; public static void lruCacheByHand () &#123; Map&lt;Integer, Integer&gt; buffer = new LinkedHashMap&lt;&gt;(10, 0.75f, false); for (int i = 0; i &lt; 10; i++) &#123; buffer.put(i, i); &#125; System.out.println(buffer.toString()); getByHand(buffer,1); System.out.println("手动访问元素1后: " + buffer.toString()); addByHand(buffer,11); System.out.println("手动添加元素11后: " + buffer.toString()); &#125; private static void addByHand (Map&lt;Integer, Integer&gt; buffer, int num) &#123; if (buffer.size() &lt; 10) buffer.put(num, num); else &#123; buffer.remove(buffer.entrySet().iterator().next().getKey()); buffer.put(num, num); &#125; &#125; private static void getByHand (Map&lt;Integer, Integer&gt; buffer, int num) &#123; if (buffer.containsKey(num)) &#123; Integer key = num; Integer value = buffer.get(key); buffer.remove(key); buffer.put(key, value); &#125; else &#123; return; &#125; &#125; public static void main (String[] args) &#123; LRU.lruByLinkedHashMap(); LRU.lruCacheByHand(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP]]></title>
    <url>%2F2018%2F09%2F13%2FKMP%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[KMP 字符串匹配算法“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package Algorithm;public class KMP &#123; public static int kmp (String target, String pattern) &#123; int i = 0, j = 0; int res = 0; int[] next = getNextArray2(pattern); while (i &lt; pattern.length() &amp;&amp; j &lt; target.length()) &#123; if (i == -1 || pattern.charAt(i) == target.charAt(j)) &#123; i++; j++; &#125; else &#123; /** 回退 * ABCDABD * 如最后一位没有匹配到，则需回退到下标2 */ i = i - 1 &gt; 0 ? next[i - 1] : -1; &#125; &#125; if (i == pattern.length()) return j; else return -1; &#125; /** * 计算出的数组A表示以这一位位阶为的最长前后缀 * 而next数组则为数组A右移一位，第一个值赋为-1 * 如ABCDABD * getNextArray计算出来：0 0 0 0 1 2 0 * 真正的next：-1 0 0 0 0 1 2 */ public static int[] getNextArray (String pattern) &#123; int[] next = new int[pattern.length()]; next[0] = 0; for (int i = 1; i &lt; pattern.length(); i++) &#123; /** * ABCABD * 判断D与C是否相等 * 类似于动态规划 */ if (pattern.charAt(next[i - 1]) == pattern.charAt(i)) next[i] = next[i - 1] + 1; else &#123; /** * 不相等，递归next * ABABCABABD * D不等于C,递归next[C的下标 - 1] */ int j = next[i - 1]; while (j &gt; 0) &#123; if (pattern.charAt(j) == pattern.charAt(i)) next[i] = j + 1; else j = next[j-1]; &#125; if (j == 0 &amp;&amp; pattern.charAt(0) == pattern.charAt(i)) next[i] = 1; else next[i] = 0; &#125; &#125; return next; &#125; //直接求next数组 public static int[] getNextArray2 (String pattern) &#123; int[] next = new int[pattern.length()]; next[0] = -1; int i = 0, j = -1; while (i &lt; pattern.length()-1) &#123; if (j == -1 || pattern.charAt(j) == pattern.charAt(i)) &#123; ++i; ++j; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125; return next; &#125; public static void main (String[]args)&#123; KMP.kmp("BBC_ABCDAB_ABCDABCDABDE", "ABABBCABB"); &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 41】First Missing Positive 缺失的第一个正数]]></title>
    <url>%2F2018%2F09%2F10%2F%E3%80%90LeetCode%2041%E3%80%91First%20Missing%20Positive%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334/** * 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 * 输入: [1,2,0] * 输出: 3 * 示例 2: * 输入: [3,4,-1,1] * 输出: 2 * 示例 3: * 输入: [7,8,9,11,12] * 输出: 1 * * 下标i存储i+1，若为负数或超出数组长度则位置不变 * 找出第一个nums[i] != i+1即为所解 */public class leetcode41 &#123; public int firstMissingPositive(int[] nums) &#123; int i = 0, n = nums.length; if (n == 0) return 1; while (i &lt; n) &#123; if (nums[i] != i + 1 &amp;&amp; nums[i] &gt; 0 &amp;&amp; nums[i] &lt; n &amp;&amp; nums[nums[i] - 1] != nums[i]) &#123; int t = nums[nums[i] - 1]; nums[nums[i] - 1] = nums[i]; nums[i] = t; &#125; else ++i; &#125; for (i = 0; i &lt; n; i++) &#123; if (nums[i] != i + 1) return i + 1; &#125; return n + 1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 62】Unique Paths 不同路径]]></title>
    <url>%2F2018%2F09%2F10%2F%E3%80%90LeetCode%2062%E3%80%91Unique%20Paths%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 * 问总共有多少条不同的路径？ * * dp[i][j]表示从原点到i，j总路径数目 * 转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1] 到i，j的路径数目等于到上面一个点与左面一个点数目之和 */public class leetcode62 &#123; public int uniquePaths (int m, int n) &#123; int[][] dp = new int[n][m]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (i == 0 || j == 0) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; System.out.print(dp[i][j] + " "); &#125; System.out.println(); &#125; return dp[n - 1][m - 1]; &#125; /** * O(n)空间复杂度 * 7=6+1 * 7上一轮为1 */ public int uniquePaths2 (int m, int n) &#123; int[] dp = new int[m]; dp[0] = 1; for (int i = 0; i &lt; n; i++) &#123; for (int j = 1; j &lt; m; j++) &#123; dp[j] += dp[j - 1]; &#125; &#125; return dp[m - 1]; &#125; public static void main (String[] args) &#123; new leetcode62().uniquePaths(7, 3); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 63】Unique Paths II 不同路径II]]></title>
    <url>%2F2018%2F09%2F10%2F%E3%80%90LeetCode%2063%E3%80%91Unique%20Paths%20II%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 * 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ * 网格中的障碍物和空位置分别用 1 和 0 来表示。 */public class leetcode63 &#123; public static int uniquePathsWithObstacles (int[][] obstacleGrid) &#123; if (obstacleGrid.length &lt;= 0) return 0; if (obstacleGrid[0][0] == 1) return 0; int n = obstacleGrid.length; int m = obstacleGrid[0].length; int[][] dp = new int[n][m]; dp[0][0] = 1; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (obstacleGrid[i][j] == 1) &#123; dp[i][j] = 0; continue; &#125; if (i == 0 || j == 0) dp[i][j] = dp[i &gt; 0 ? i - 1 : 0][j &gt; 0 ? j - 1 : 0]; else &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; &#125; return dp[n - 1][m - 1]; &#125; //O(m)空间复杂度 /** *要注意的是因为有可能存在障碍物，所以i或j为0时不再是总为1了 */ public static int uniquePathWithObstacles2 (int[][] obstacleGrid) &#123; if (obstacleGrid[0][0] == 1) &#123; return 0; &#125; int n = obstacleGrid.length; int m = obstacleGrid[0].length; int[] dp = new int[m]; dp[0] = 1; for (int i = 0; i &lt; n; i++) &#123; dp[0] = obstacleGrid[i][0] == 1 ? 0 : dp[0]; for (int j = 1; j &lt; m; j++) &#123; if (obstacleGrid[i][j] != 1) dp[j] += dp[j - 1]; else dp[j] = 0; &#125; &#125; return dp[m - 1]; &#125; public static void main (String []args) &#123; leetcode63.uniquePathWithObstacles2(new int [][]&#123;&#123;0&#125;,&#123;0&#125;&#125;); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 476】Number Complement 数字的补数]]></title>
    <url>%2F2018%2F09%2F10%2F%E3%80%90LeetCode%20476%E3%80%91Number%20Complement%20%20%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819/** * 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。 * 注意: * 给定的整数保证在32位带符号整数的范围内, * 你可以假定二进制数不包含前导零位。 * * 对二进制取反，其实就是与相同位数全为1的二进制异或 * Integer.highestOneBit(n),比如n二进制位1100，则计算出的结果为10000，所以全为1用前面所求的值-1即可 */public class leetcode476 &#123; public static int findComplement (int num) &#123; int mask = (Integer.highestOneBit(num) &lt;&lt; 1) - 1; return mask ^ num; &#125; public static void main (String[] args) &#123; System.out.print(leetcode476.findComplement(5)); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 692】Top K Frequent Words 前K个高频单词]]></title>
    <url>%2F2018%2F09%2F10%2F%E3%80%90LeetCode%20692%E3%80%91Top%20K%20Frequent%20Words%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * * 给一非空的单词列表，返回前 k 个出现次数最多的单词。 * 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。 * * 放到map中按次数排序再按字典序排序 * 重写比较器，可以这么写Comparator.comparing(Map.Entry&lt;String,Integer&gt;::getValue) * 但是感觉不灵活，也不好用 */public class leetcode692 &#123; public List&lt;String&gt; topKFrequent (String[] words, int k) &#123; if (words.length == 0) return null; List&lt;String&gt; res = new LinkedList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; words.length; i++) &#123; if (map.containsKey(words[i])) map.put(words[i], map.get(words[i])+1); else map.put(words[i],1); &#125; List&lt;Map.Entry&lt;String,Integer&gt;&gt; list = new LinkedList&lt;&gt;(map.entrySet()); Collections.sort(list, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123; @Override public int compare (Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) &#123; //次数不相等按次数排序 if(o1.getValue()!=o2.getValue()) return o1.getValue().compareTo(o2.getValue()); //相等按字典序排序 else return -o1.getKey().compareTo(o2.getKey()); &#125; &#125;); for(int i=list.size()-1;k&gt;0;k--,i--)&#123; res.add(list.get(i).getKey()); &#125; return res; &#125; public static void main(String []args)&#123; new leetcode692().topKFrequent(new String[]&#123; "a", "b","b", "c", "c", "d", "b","d"&#125;,1); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 106】Construct Binary Tree from Inorder and Postorder Traversal 从中序与后序遍历序列构造二叉树]]></title>
    <url>%2F2018%2F09%2F10%2F%E3%80%90LeetCode%20106%E3%80%91Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334/** * 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 * 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 * 必须原地修改，只允许使用额外常数空间。 * * 下一个全排列就是找到比当前数大的最小值，找到降序排列开始的位置，记为i，从i到n找到比nums[i-1]大的最小值与i-1交换， * 并将交换后i之后序列按升序排列，若整个序列都为降序则反转 */public class leetcode31 &#123; public void nextPermutation (int[] nums) &#123; int i = nums.length - 1; while (i &gt; 0 &amp;&amp; nums[i] &lt;= nums[i - 1]) &#123; i--; &#125; if(i==0) Arrays.sort(nums); else&#123; int index = nums[i-1]; int j; for(j=nums.length-1;j&gt;=i;j--)&#123; if(nums[j]&gt;index) break; &#125; int temp = nums[i-1]; nums[i-1]=nums[j]; nums[j]=temp; Arrays.sort(nums,i,nums.length); &#125; &#125; public static void main(String []args)&#123; new leetcode31().nextPermutation(new int[]&#123;5,1,1&#125;); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 199】Binary Tree Right Side View 二叉树的右视图]]></title>
    <url>%2F2018%2F09%2F10%2F%E3%80%90LeetCode%20199%E3%80%91Binary%20Tree%20Right%20Side%20View%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637/** * 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 * * 层次遍历，输出每一行末尾节点 */public class leetcode199 &#123; /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ public static List&lt;Integer&gt; rightSideView (TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); int size = 1; queue.offer(root); while (!queue.isEmpty()) &#123; res.add((((LinkedList&lt;TreeNode&gt;) queue).peekLast().val)); for (int i = 0; i &lt; size; i++) &#123; TreeNode r = queue.poll(); if (r.left != null) queue.offer(r.left); if (r.right != null) queue.offer(r.right); &#125; size = queue.size(); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 31】Next Permutation 下一个排列]]></title>
    <url>%2F2018%2F09%2F10%2F%E3%80%90LeetCode%2031%E3%80%91Next%20Permutation%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 CODE123456789101112131415161718192021222324252627282930313233/** * 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 * 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 * 必须原地修改，只允许使用额外常数空间。 * * 下一个全排列就是找到比当前数大的最小值，找到降序排列开始的位置，记为i，从i到n找到比nums[i-1]大的最小值与i-1交换， * 并将交换后i之后序列按升序排列，若整个序列都为降序则反转 */public class leetcode31 &#123; public void nextPermutation (int[] nums) &#123; int i = nums.length - 1; while (i &gt; 0 &amp;&amp; nums[i] &lt;= nums[i - 1]) &#123; i--; &#125; if(i==0) Arrays.sort(nums); else&#123; int index = nums[i-1]; int j; for(j=nums.length-1;j&gt;=i;j--)&#123; if(nums[j]&gt;index) break; &#125; int temp = nums[i-1]; nums[i-1]=nums[j]; nums[j]=temp; Arrays.sort(nums,i,nums.length); &#125; &#125; public static void main(String []args)&#123; new leetcode31().nextPermutation(new int[]&#123;5,1,1&#125;); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 40】Combination Sum II 组合总和 II]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%2040%E3%80%91Combination%20Sum%20II%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * * 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 * candidates 中的每个数字在每个组合中只能使用一次。 * * 先排序，再去重 */public class leetcode40 &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(candidates); helper(candidates, target, 0, res, new ArrayList&lt;&gt;()); return res; &#125;// private void helper(int[] nums, int target, int pos, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; bag) &#123;// if (target == 0)// res.add(new ArrayList&lt;&gt;(bag));// if (target &lt; 0)// return;// if (pos &gt;= nums.length)// return;// else &#123;// List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(bag);// helper(nums, target, pos + 1, res, bag);// bag =temp;// bag.add(nums[pos]);// helper(nums, target - nums[pos], pos + 1, res, bag);// &#125;//// &#125; private void helper(int[] nums, int target, int pos, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; bag) &#123; if (target == 0) res.add(new ArrayList&lt;&gt;(bag)); if (target &lt; 0) return; else &#123; for (int i = pos; i &lt; nums.length; i++) &#123; //去重 if (i &gt; pos &amp;&amp; nums[i] == nums[i - 1]) continue; bag.add(nums[i]); helper(nums, target-nums[i], i + 1, res, bag); bag.remove(bag.size() - 1); &#125; &#125; &#125; public static void main(String []args) &#123; new leetcode40().combinationSum2(new int []&#123;10,1,2,7,6,1,5&#125;, 8); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 39】 Combination Sum 组合总和]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%2039%E3%80%91%20Combination%20Sum%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031/** * 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 * candidates 中的数字可以无限制重复被选取。 * * dfs即可 */public class leetcode39 &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum (int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); helper(res, new LinkedList&lt;Integer&gt;(), target, candidates,0); return res; &#125; private void helper (List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; bag, int target, int[] nums,int pos) &#123; if (target == 0) &#123; res.add(bag); return; &#125; if (target &lt; 0) return; else &#123; for (int i = pos; i &lt; nums.length; i++) &#123; List&lt;Integer&gt; temp = new LinkedList&lt;&gt;(bag); bag.add(nums[i]); helper(res, bag, target - nums[i], nums,i); bag = temp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 8】String to Integer (atoi) 字符串转整数 (atoi)]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%208%E3%80%91String%20to%20Integer%20(atoi)%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%20(atoi)%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 实现 atoi，将字符串转为整数。 * 在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来, * 这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 * 字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。 * 当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。 * 若函数不能执行有效的转换，返回 0。 * 说明：假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。如果数值超过可表示的范围，则返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 */public class leetcode8 &#123; public static int myAtoi(String str) &#123; StringBuilder sb=new StringBuilder(); for(int i=0;i&lt;str.length();i++) &#123; if (str.charAt(i) != ' ')&#123; str =str.substring(i); break; &#125; &#125; if(str.length()==0) return 0; if(str.length()&gt;=2&amp;&amp;str.charAt(0)=='+'&amp;&amp;(str.charAt(1)&lt;'0'|| str.charAt(1)&gt;'9')) return 0; if(str.length()==1&amp;&amp; (str.charAt(0)=='-'||str.charAt(0)=='+')) return 0; if(str.charAt(0)=='+') str=str.substring(1); if(str.length()&gt;=2&amp;&amp;str.charAt(0)=='-'&amp;&amp;(str.charAt(1)&lt;'0'|| str.charAt(1)&gt;'9')) return 0; if((str.charAt(0)&lt;'0'|| str.charAt(0)&gt;'9')&amp;&amp;str.charAt(0)!='-') return 0; if(str.equals(String.valueOf(Integer.MAX_VALUE))) return Integer.MAX_VALUE; if(str.equals(String.valueOf(Integer.MIN_VALUE))) return Integer.MIN_VALUE; int length = str.length(); int ans=0; StringBuilder result = new StringBuilder(); for(int i=0;i&lt;length;i++)&#123; if( i==0 &amp;&amp; str.charAt(i)=='-') &#123; result.append('-'); continue; &#125; if(str.charAt(i)&lt;'0'|| str.charAt(i)&gt;'9') break; else result.append(str.charAt(i)); &#125; char f = result.charAt(0); String s = new StringBuilder(result.reverse().toString().split("-")[0]).reverse().toString(); try&#123; ans = Integer.valueOf(s); &#125;catch(Exception e)&#123; ans= f=='-'?Integer.MIN_VALUE:Integer.MAX_VALUE; &#125; return f=='-'?0-ans:ans; &#125; public static void main(String []args)&#123; System.out.print( leetcode8.myAtoi("-w")); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 2】Add Two Numbers 两数相加]]></title>
    <url>%2F2018%2F09%2F09%2FLeetCode%202%E3%80%91Add%20Two%20Numbers%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * * 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 * 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 * */public class leetcode2 &#123; public static ListNode addTwoNumbers (ListNode l1, ListNode l2) &#123; ListNode res = new ListNode(0); ListNode temp = res; int flag = 0; int dight = 0; while (l1 != null &amp;&amp; l2 != null) &#123; dight = l1.val + l2.val; res.next = new ListNode((flag + dight) % 10); flag = (flag+dight) / 10; res = res.next; if (l1.next == null &amp;&amp; l2.next == null) break; if (l1.next == null) l1.next = new ListNode(0); if (l2.next == null) l2.next = new ListNode(0); l1 = l1.next; l2 = l2.next; &#125; if (l1.next == null &amp;&amp; l2.next == null &amp;&amp; flag != 0) res.next = new ListNode(flag); return temp.next; &#125; public static void main (String[] args) &#123; ListNode p1 = new ListNode(9); ListNode p2 = new ListNode(9); p1.next = p2; ListNode q1 = new ListNode(1); leetcode2.addTwoNumbers(q1, p1); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 53】Maximum Subarray 最大子序和]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%2053%E3%80%91Maximum%20Subarray%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415/** * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 */public class leetcode53 &#123; public int maxSubArray(int[] nums) &#123; int dp[] = new int[nums.length]; dp[0] = nums[0]; int max = dp[0]; for (int i = 1; i &lt; nums.length; i++) &#123; dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); max = Math.max(dp[i], max); &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 31】Next Permutation 下一个排列]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%20105%E3%80%91Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 根据一棵树的前序遍历与中序遍历构造二叉树 * 注意: * 你可以假设树中没有重复的元素。 * * 递归构建 */public class leetcode105 &#123; /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ //根据前序和中序构件树 public TreeNode buildTree (int[] preorder, int[] inorder) &#123; return helper(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); &#125; private TreeNode helper (int[] preorder, int preS, int preE, int[] inorder, int inS, int inE) &#123; if (preS &gt; preE || inS &gt; inE) return null; TreeNode res = new TreeNode(preorder[preS]); int pos = inS; for (int i = inS; i &lt;= inE; i++) &#123; if (inorder[i] == preorder[preS]) &#123; pos = i; break; &#125; &#125; //这个preE要算准确 res.left = helper(preorder, preS + 1, preS + pos-inS, inorder, inS, pos - 1); res.right = helper(preorder, preS + pos-inS+1, preE, inorder, pos + 1, inE); return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 11】Container With Most Water 盛最多水的容器]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%2011%E3%80%91Container%20With%20Most%20Water%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 1234567891011121314151617181920212223242526272829303132/** * * 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线， * 垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线， * 使得它们与 x 轴共同构成的容器可以容纳最多的水。 * 说明：你不能倾斜容器，且 n 的值至少为 2。 * * 最大面积取决于短边，所以每次移动较短的一边即可 */public class leetcode11 &#123; public static int maxArea (int[] height) &#123; if (height.length &lt; 2) return 0; int left = 0; int right = height.length-1; int max = 0; while (left &lt; right) &#123; int h = Math.min(height[left], height[right]); max = Math.max(max, h * (right - left)); if (h == height[left]) left++; else right--; &#125; return max; &#125; public static void main(String []args)&#123; int []h = &#123;1,8,6,2,5,4,8,3,7&#125;; leetcode11.maxArea(h); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 55】Jump Game 跳跃游戏]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%2055%E3%80%91Jump%20Game%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021/** * 给定一个非负整数数组，你最初位于数组的第一个位置。 * 数组中的每个元素代表你在该位置可以跳跃的最大长度。 * 判断你是否能够到达最后一个位置。 * * 不断更新你能到达的最大位置 */public class leetcode55 &#123; public boolean canJump (int[] nums) &#123; if (nums.length == 1) return true; int max = 0; //注意是小于max for (int i = 0; i &lt;= max; i++) &#123; max = Math.max(max,nums[i]+i); if (max &gt;= nums.length-1) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 19】Remove Nth Node From End of List 删除链表的倒数第N个节点]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%2019%E3%80%91Remove%20Nth%20Node%20From%20End%20of%20List%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425262728293031/** * * 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 * 一趟扫描 * 两个指针，一个先走n步，然后两个指针同时走，第一个指针到末尾，第二个指针的位置就是倒数第n个节点 * */public class leetcode19 &#123; public ListNode removeNthFromEnd (ListNode head, int n) &#123; ListNode i = head, j = head; for (int k = 0; k &lt; n; k++) &#123; j = j.next; &#125; ListNode temp = i; while (j != null) &#123; j = j.next; temp = i; i = i.next; &#125; if (temp == i) &#123; head = head.next; return head; &#125; else &#123; temp.next = i.next; i.next = null; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 26】Remove Duplicates from Sorted Array 删除排序数组中的重复项]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%2026%E3%80%91Remove%20Duplicates%20from%20Sorted%20Array%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 1234567891011121314151617/** * 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 * 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 */public class leetcode26 &#123; public int removeDuplicates (int[] nums) &#123; int pos = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[pos] != nums[i]) &#123; pos++; nums[pos] = nums[i]; &#125; &#125; return pos+1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 27】Remove Element 移除元素]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%2027%E3%80%91Remove%20Element%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021/** * 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 * 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 * 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 */public class leetcode27 &#123; public int removeElement (int[] nums, int val) &#123; int count=0; int pos=nums.length-1; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; if (nums[i] == val) &#123; int t = nums[pos]; nums[pos] = nums[i]; nums[i] = t; count++; pos--; &#125; &#125; return nums.length - count; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 57】 Insert Interval 插入区间]]></title>
    <url>%2F2018%2F09%2F09%2F%5BLeetCode%2057%5D%20Insert%20Interval%20%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[[LeetCode 57] Insert Interval 插入区间“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 给出一个无重叠的 ，按照区间起始端点排序的区间列表。 * 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 * * copy 56，把要加入的区间放到集合中合并 */public class leetcode57 &#123; public class Interval &#123; int start; int end; Interval () &#123; start = 0; end = 0; &#125; Interval (int s, int e) &#123; start = s; end = e; &#125; &#125; public List&lt;Interval&gt; insert (List&lt;Interval&gt; intervals, Interval newInterval) &#123; intervals.add(newInterval); return merge(intervals); &#125; public List&lt;Interval&gt; merge (List&lt;Interval&gt; intervals) &#123; Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare (Interval o1, Interval o2) &#123; return Integer.compare(o1.start, o2.start); &#125; &#125;); List&lt;Interval&gt; res = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; intervals.size(); i++) &#123; Interval left = intervals.get(i - 1); Interval right = intervals.get(i); Interval mergeInterval = new Interval(); if (right.start &lt;= left.end) &#123; mergeInterval = new Interval(left.start, Math.max(left.end, right.end)); intervals.set(i, mergeInterval); &#125; else res.add(intervals.get(i - 1)); &#125; res.add(intervals.get(intervals.size() - 1)); return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 31】Merge Intervals 合并区间]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%2031%E3%80%91Merge%20Intervals%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 给出一个区间的集合，请合并所有重叠的区间。 * 示例 1: * 输入: [[1,3],[2,6],[8,10],[15,18]] * 输出: [[1,6],[8,10],[15,18]] * 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. * 示例 2: * 输入: [[1,4],[4,5]] * 输出: [[1,5]] * 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 * * 按照左边界排序，然后两两合并 */public class leetcode56 &#123; public static class Interval &#123; int start; int end; Interval() &#123; start = 0; end = 0; &#125; Interval(int s, int e) &#123; start = s; end = e; &#125; &#125; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return Integer.compare(o1.start, o2.start); &#125; &#125;); List&lt;Interval&gt; res = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; intervals.size(); i++) &#123; Interval left = intervals.get(i - 1); Interval right = intervals.get(i); Interval mergeInterval = new Interval(); if (right.start &lt;= left.end) &#123; mergeInterval = new Interval(left.start, Math.max(left.end, right.end)); intervals.set(i,mergeInterval); &#125; else res.add(intervals.get(i - 1)); &#125; res.add(intervals.get(intervals.size() - 1)); return res; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 35】Search Insert Position 搜索插入位置]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%2035%E3%80%91Search%20Insert%20Position%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 12345678910111213141516171819202122232425/** * 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 * 你可以假设数组中无重复元素。 * * 二分查找下界 */public class leetcode35 &#123; public int searchInsert (int[] nums, int target) &#123; return boundSearch(nums,0,nums.length,target); &#125; public int boundSearch (int[] nums, int left, int right, int target) &#123; while (left &lt; right) &#123; int mid = (left + right) / 2; if (nums[mid] &gt; target) right = mid; else if(nums[mid] == target) return mid; else left =mid+1; &#125; return left; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 367】Valid Perfect Square 有效的完全平方数]]></title>
    <url>%2F2018%2F09%2F09%2F%E3%80%90LeetCode%20367%E3%80%91Valid%20Perfect%20Square%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%20%2F</url>
    <content type="text"><![CDATA[“The Linux philosophy is “Laugh in the face of danger”.Oops.Wrong One. “Do it yourself”. Yes, that”s it.”Linux的哲学就是“在危险面前放声大笑”，呵呵，不是这句，应该是“一切靠自己，自力更生”才对。 123456789101112131415161718192021222324252627/** * 给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 * 说明：不要使用任何内置的库函数，如 sqrt。 * * 二分查找 * 一个数的平方根一定小于这个数的一半 */public class leetcode367 &#123; public static boolean isPerfectSquare (int num) &#123; if (num &lt; 1) return false; if (num == 1) return true; long left = 0; long right = num / 2; while (left &lt;= right) &#123; long mid = (left + right) / 2; if (mid * mid == num) return true; else if (mid * mid &lt; num) left = mid + 1; else right = mid - 1; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCS(substring) | LCS(subsequence) | LIS]]></title>
    <url>%2F2018%2F09%2F04%2FLCS(%E5%AD%90%E4%B8%B2)%E3%80%81LCS(%E5%AD%90%E5%BA%8F%E5%88%97)%E3%80%81LIS%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[LongestCommonSubstring 最长公共子串动态规划解法：dp[i][j]表示以si和tj结尾的公共子串的最大长度；则转移方程为：dp[i][j] = si == tj ? 1 : 0 , i==0||j==0dp[i][j] = s1[i] == s2[j] ? dp[i-1][j-1]+1 : 0 ,other CODE1234567891011121314151617181920212223242526272829303132/** * 最长公共子串 * dp[i][j]表示以以i、j结尾的以s1[i]、s2[j]为结尾的相同子串的最大长度 * dp[i][j] = s1[i] == s2[j] ? 1 : 0 ,i==0||j==0 * dp[i][j] = s1[i] == s2[j] ? dp[i-1][j-1]+1 : 0 */ public static int longestCommonSubstring (String s1, String s2) &#123; int[][] dp = new int[s1.length()][s2.length()]; int max=0; int x=0,y=0; for (int i = 0; i &lt; s1.length(); i++) &#123; for (int j = 0; j &lt; s2.length(); j++) &#123; if (i == 0 || j == 0) dp[i][j] = s1.charAt(i) == s2.charAt(j) ? 1 : 0; else dp[i][j] = s1.charAt(i) == s2.charAt(j) ? dp[i - 1][j - 1] + 1 : 0; max = Math.max(max,dp[i][j]); if(max==dp[i][j])&#123; x=i; y=j; &#125; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int i=x,j=y;i&gt;=0&amp;&amp;j&gt;=0&amp;&amp;dp[i][j]&gt;=1;i--,j--) sb.append(s1.charAt(i)); System.out.println(sb.reverse().toString()); return max; &#125; public static void main (String []args) &#123; System.out.println(LCSubstring.longestCommonSubstring("acbcbce","abcbced")); &#125; NOTE輸出最大子串：记录最大子串值和位置，沿对角线遍历（–1；–j），因为子串是连续的正确路径只会是对角线 LongesetCommonSubsequence 最长公共子序列动态规划解法：dp[i][j]表示s0…si与t0…tj最长公共子序列转移方程：dp[i][j] = s[i]== t[j] ? 1 : 0, i==0 and j==0;dp[i][j] = s[i]== t[j] ? 1 : dp[i == 0 ? 0 : i - 1][j == 0 ? 0 : j - 1],i==0 or j==0 and i!=j;dp[i][j] = dp[i-1][j-1] + 1, s[i] == t[j];dp[i][j] = max(dp[i-1][j], dp[i][j-1]), s[i] != t[j]; CODE:123456789101112131415161718192021222324252627282930313233343536373839public static int LongestCommonSubsequence (String s1, String s2) &#123; int[][] dp = new int[s1.length()][s2.length()]; int max = 0; for (int i = 0; i &lt; s1.length(); i++) &#123; for (int j = 0; j &lt; s2.length(); j++) &#123; if (i == 0 &amp;&amp; j == 0) dp[i][j] = s1.charAt(i) == s2.charAt(j) ? 1 : 0; else if (i == 0 || j == 0) &#123; if (s1.charAt(i) == s2.charAt(j)) dp[i][j] = 1; else dp[i][j] = dp[i == 0 ? 0 : i - 1][j == 0 ? 0 : j - 1]; &#125; else &#123; if (s1.charAt(i) == s2.charAt(j)) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; max = Math.max(max, dp[i][j]); System.out.print(dp[i][j]); &#125; System.out.println(); &#125; return max; &#125; public static void showSubsequence (int[][] dp, String s, String t) &#123; int i = s.length() - 1, j = t.length() - 1; StringBuilder sb = new StringBuilder(); while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if (s.charAt(i) == s.charAt(j)) &#123; sb.append(s.charAt(i)); ++i; ++j; &#125; else &#123; &#125; &#125; &#125; NOTE:关于输出，从dp表最后一位开始遍历，若相对的字符相等则添加，遍历–i与–j，若不等，比较–i，j与i，–j大小，遍历大者，若相等（搞清楚后补充）。。。 LIS 最长非递减序列动态规划解法：dp[i]表示里nums[i]为结尾的lis转移方程：dp[i] = max(dp[i],d[j]+1),s[j]&lt;=s[i] CODE:123456789101112131415public static int LIS(int[] nums) &#123; int[] dp = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; dp[i] = 1; &#125; int max = 0; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[j] &lt;= nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1); &#125; max = Math.max(dp[i], max); &#125; return max; &#125; 贪心+二分：贪心：使得加入最后一位的值尽可能的小，这样序列才更容易增加二分：搜索当前添加元素在已添加数组的下边界（加入的位置，数组都是排好序的）将元素加入res数组，如果带加入的数字大于res数组的最后一位，则直接添加，否则二分查找要替换的位置,最后res数组大小即为结果（注意res数组内容并不是要求数列） CODE:123456789101112131415161718192021222324252627282930/** * 贪心+二分 nlogn */ public static int LIS (int[] nums) &#123; int[] res = new int[nums.length]; int size = 0; res[size++] = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt;= res[size - 1]) &#123; res[size++] = nums[i]; &#125; else &#123; res[lower_bound(0, size - 1, res, nums[i])] = nums[i]; &#125; &#125; return res.length; &#125; /** * 二分查下界 */ public static int lower_bound (int left, int right, int[] nums, int target) &#123; while (left &lt; right) &#123; int mid = (left + right) / 2; if (nums[mid] &gt;= target) right = mid; else left = mid + 1; &#125; return left; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F09%2F02%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集 union-find并查集其实就是构建一个森林，对有公共父节点的多叉树合并。问题：假如有1-10个人，互相认识的人构成一个朋友圈，两个朋友圈中没有相互认识的两个人，问能够构成几个盆友圈。 solution开一个size数组，下标代表每个人所认识的人数，parent数组下标代表自己的父节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class unionFind &#123; public static int solution (List&lt;List&lt;Integer&gt;&gt; list) &#123; int[] size = new int[10]; int[] parent = new int[10]; for (int i = 0; i &lt; size.length; i++) &#123; size[i] = 0; parent[i] = i; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i).size() != 0) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); if (parent[i] != i) set.add(parent[i]); for (Integer t : list.get(i)) &#123; int root = find(t, parent); if (root != t) &#123; set.add(root); continue; &#125; if (parent[i] != t) &#123; parent[t] = i; size[i]++; size[t]--; &#125; &#125; for (Integer t : set) &#123; union(t, i, size, parent); &#125; &#125; &#125; for (int i = 0; i &lt; parent.length; i++) &#123; if (parent[i] != find(i, parent)) &#123; size[i] += size[parent[i]]; size[parent[i]] = -1; parent[i] = find(i, parent); &#125; &#125; int count = 0; for (int i = 0; i &lt; size.length; i++) if (size[i] &gt;= 0) count++; return count; &#125; //寻找自己的根节点 private static int find (int x, int[] parent) &#123; if (parent[x] == x) return x; else return find(parent[x], parent); &#125; //合并有相同父节点的两棵树 private static void union (int l, int r, int[] size, int[] parent) &#123; int xparent = find(l, parent); int yparent = find(r, parent); if (xparent == yparent) return; for (int i = 0; i &lt; parent.length; i++) &#123; if (find(i, parent) == yparent) &#123; parent[i] = xparent; size[xparent]++; size[yparent]--; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧几里得算法和牛顿迭代法]]></title>
    <url>%2F2018%2F08%2F28%2F%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%92%8C%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[欧几里得算法和牛顿迭代法求最大公约数辗转相除法：f(x,y) = f(y,x%y),x和y的最大公约数和y和x%的最大公约数相同12345678public static int Gcd (int a, int b) &#123; while (b &gt; 0) &#123; int temp = a % b; a = b; b = temp; &#125; return a; &#125; 求平方根牛顿迭代法： k=(k+x/k)/2 123456789public static double Sqrt (int x) &#123; double res=0; double last=x; while(Math.abs(res-last)&gt;0.000000001)&#123; res = last; last = (res+(x/res))/2; &#125; return res; &#125; 之前也听说卡马克快速平方根倒数算法，好奇这几个平方根算法哪个更快cmark: 12345678910111213public static double cmark(int number) &#123; int i; float x2, y; float threehalfs = 1.5F; x2 = number * 0.5F; y = number; i = Float.floatToRawIntBits(y); // evil floating point bit level hacking i = 0x5f3759df - (i &gt;&gt; 1); // what the fuck? y = Float.intBitsToFloat(i); y = y * (threehalfs - (x2 * y * y)); // 1st iteration y = y * (threehalfs - (x2 * y * y)); // 2nd iteration, this can be removed return 1 / y; &#125; 结果是库函数最快，其次是牛顿迭代法（和库函数差不多），卡马克稍慢，啊哈哈哈]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 74】Search a 2D Matrix 搜索二维矩阵]]></title>
    <url>%2F2018%2F08%2F28%2F%E3%80%90LeetCode%2074%E3%80%91Search%20a%202D%20Matrix%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20%2F</url>
    <content type="text"><![CDATA[【LeetCode 74】Search a 2D Matrix 搜索二维矩阵问题描述:编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。每行的第一个整数大于前一行的最后一个整数。 说明：解集不能包含重复的子集。 示例1:输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 输出: true Solution:Solution: 二维矩阵从左到右、从上到下均为升序，可以用两次二分查找，先定位到元素所在行，再在本行查找元素即可。 Code:class solution { public static boolean searchMatrix (int[][] matrix, int target) { int n = matrix.length; if(n==0) return false; int m = matrix[0].length; if(m==0) return false; int i = 0, j = n - 1, midColumn = 0; while (i &lt;= j) { midColumn = (i + j) / 2; if (matrix[midColumn][0] &lt;= target &amp;&amp; target &lt;= matrix[midColumn][m - 1]) break; if(target&lt;matrix[midColumn][0]) j=midColumn-1; else i=midColumn+1; } if (i &gt; j) return false; int p = 0, q = m - 1, midRow = 0; while (p &lt;= q) { midRow = (p + q) / 2; if (matrix[midColumn][midRow] == target) return true; else if(matrix[midColumn][midRow]&lt;target) p=midRow+1; else q=midRow-1; } return false; } }]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 90】Subsets II 子集II]]></title>
    <url>%2F2018%2F08%2F24%2F%E3%80%90LeetCode%2090%E3%80%91Subsets%20II%20%E5%AD%90%E9%9B%86II%2F</url>
    <content type="text"><![CDATA[【LeetCode 90】Subsets II 子集II问题描述:给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:12345678910输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] Solution:Solution: 这道问题相对于leetcode78差别在于包含重复元素，所以这道题要解决的就是去重，也就是dfs的时候减枝，考虑序列1，2，2，2，当要回溯到1，2时，遍历下一位判断与上一位是否相同，若相同跳过即可去重，当然这么做的前提条件是原序列是有序的，所以要在原序列做个排序。 Code:12345678910111213141516171819class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup (int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); Arrays.sort(nums); helper(res, new LinkedList&lt;Integer&gt;(), 0, nums); return res; &#125; private void helper (List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; bag, int pos, int[] nums) &#123; res.add(new LinkedList&lt;&gt;(bag)); for (int i = pos; i &lt; nums.length; i++) &#123; if (i &gt; pos &amp;&amp; nums[i] == nums[i - 1]) continue; List&lt;Integer&gt; temp = new LinkedList&lt;&gt;(bag); bag.add(nums[i]); helper(res, bag, i + 1, nums); bag = temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jdk动态代理实现自定义拦截器]]></title>
    <url>%2F2018%2F08%2F22%2F%E4%BD%BF%E7%94%A8Jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[使用Jdk动态代理实现自定义拦截器接口：public interface IUser { public String getName(); } 实现类：public class User implements IUser { private String name; public User(String name){ this.name=name; } @Override public String getName () { return name; } } 自定义拦截器接口：public interface Interceptor { boolean before(Object proxy, Object target, Method method,Object []args); void around (Object proxy,Object target,Method method,Object []args); void after(Object proxy, Object target, Method method, Object []args); } 拦截器实现类： (在调用方法前做了个简单的属性校验)这里可以实现多个拦截器实现责任链模式，target的代理是proxy1，proxy1的代理是proxy2，proxy2的代理是proxy3，这样就可以实现顺序拦截（好处是可以再责任链上任意位置添加拦截，缺点是代理和反射太多性能不高） public class MyInterceptor implements Interceptor { @Override public boolean before (Object proxy, Object target, Method method, Object[] args) { System.out.println("before"); if (checkProperties(target)) return true; return false; } @Override public void around (Object proxy, Object target, Method method, Object[] args) { System.out.println("around"); } @Override public void after (Object proxy, Object target, Method method, Object[] args) { System.out.println("After"); } private boolean checkProperties (Object object) { Field[] fields = object.getClass().getDeclaredFields(); try { for (Field field : fields) { field.setAccessible(true); if (field.get(object).equals("")) return false; } } catch (Exception e) { } return true; } } 实现InvocationHandler:流程如下： public class MyInvocationHandler implements InvocationHandler { private Object target; private Class clazz; public MyInvocationHandler(Object t,Class c){ this.target = t; this.clazz = c; } public static Object bind(Object target,Class clazz){ return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new MyInvocationHandler(target,clazz)); } @Override public Object invoke (Object proxy, Method method, Object[] args) throws Throwable { if(this.clazz==null) return method.invoke(target,args); Object result=null; Interceptor interceptor = (Interceptor) clazz.newInstance(); if(interceptor.before(proxy,target,method,args)){ result = method.invoke(target,args); }else{ interceptor.around(proxy,target,method,args); } interceptor.after(proxy,target,method,args); return result; } } 测试：public class test { public static void main(String []args){ IUser u = new User(""); IUser proxy = (IUser)MyInvocationHandler.bind(u,MyInterceptor.class); proxy.getName(); } } 运行结果:]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 784】Letter Case Permutation字母大小写全排列]]></title>
    <url>%2F2018%2F08%2F21%2F%5BLeetCode%20784%5DLetter%20Case%20Permutation%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[[LeetCode 784]Letter Case Permutation字母大小写全排列问题描述:给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。 示例:123456789示例:输入: S = &quot;a1b2&quot;输出: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]输入: S = &quot;3z4&quot;输出: [&quot;3z4&quot;, &quot;3Z4&quot;]输入: S = &quot;12345&quot;输出: [&quot;12345&quot;] 注意：S 的长度不超过12。S 仅由数字和字母组成。 Solution:Solution : 深度优先搜索即可解决 Code:beat 84%1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public static List&lt;String&gt; letterCasePermutation (String S) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); letterCasePermutationHelper(res, S, 0, new StringBuilder()); return res; &#125; private static void letterCasePermutationHelper (List&lt;String&gt; list, String s, int pos, StringBuilder sb) &#123; for (int i = pos; i &lt; s.length(); i++) &#123; if ('0' &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= '9') sb.append(s.charAt(i)); else&#123; //添加原来的字母 sb.append(s.charAt(i)); StringBuilder t = new StringBuilder(sb.toString()); letterCasePermutationHelper(list, s, i + 1, sb); sb = t; //添加转变后的字母 sb.deleteCharAt(i); sb.append(transLeeterCase(s.charAt(i))); &#125; &#125; list.add(sb.toString()); &#125; private static char transLeeterCase (char letter) &#123; char res = ' '; if ('a' &lt;= letter &amp;&amp; letter &lt;= 'z') &#123; res = (char) (letter-('a'-'A')); &#125; else if ('A' &lt;= letter &amp;&amp; letter &lt;= 'Z') &#123; res = (char) (letter+'a'-'A'); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jdk动态代理和Cglib动态代理]]></title>
    <url>%2F2018%2F08%2F20%2FJdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Jdk动态代理和Cglib动态代理Jdk动态代理：只能为接口实现代理 接口： 1234public interface IUser &#123; String getName(String name);&#125; 实现类： 123456public class User implements IUser &#123; @Override public String getName (String name) &#123; return name; &#125;&#125; 实现InvocationHandler接口： 123456789101112131415import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler &#123; private Object target; public MyInvocationHandler(Object target)&#123; this.target = target; &#125; @Override public Object invoke (Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.print(method.getName()+"\n"); return method.invoke(target,args); &#125;&#125; 调用： 1234567891011import java.lang.reflect.Proxy;public class test &#123; public static void main(String []args)&#123; IUser u = new User(); MyInvocationHandler invocationHandler = new MyInvocationHandler(u); IUser proxy = (IUser) Proxy.newProxyInstance(u.getClass().getClassLoader(),u.getClass().getInterfaces(),invocationHandler); System.out.print(proxy.getName("hello")); &#125;&#125; cglib动态代理：为类生成代理，被代理类无需实现接口，引入jar包版本asm3.31对应cglib-2.2.2（对应其他版本cglib可能会有冲突，） 被代理类不能用final修饰，要生成子类 被代理类： 123456public class User &#123; public String getName(String name)&#123; return name; &#125;&#125; 实现MethodInterceptor接口： 12345678910111213141516171819202122232425import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class UserCglib implements MethodInterceptor &#123; private Object target; public Object getInstance(Object target)&#123; this.target = target; //创建加强器，用来创建动态代理类 Enhancer enhancer = new Enhancer(); //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类） enhancer.setSuperclass(this.target.getClass()); //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦 enhancer.setCallback(this); // 创建动态代理类对象并返回 return enhancer.create(); &#125; // 实现回调方法 @Override public Object intercept (Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return methodProxy.invokeSuper(o,objects); &#125; 调用： 123456789public class test &#123; public static void main(String []args)&#123; User user = new User(); UserCglib userCglib = new UserCglib(); User proxy = (User)userCglib.getInstance(user); System.out.print(proxy.getName("hello")); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 15】3sum 三数之和]]></title>
    <url>%2F2018%2F08%2F20%2F%E3%80%90LeetCode%2015%E3%80%913sum%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[【LeetCode 15】3sum 三数之和问题描述:给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 说明：答案中不可以包含重复的三元组。 示例:1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] Solution:Solution 1: 首先想到的是以2sum为基础的利用集合解决的方法，用一个map存储所有元素，但是不能判断map重元素是否出现多次，两层循环，外层循环即为待处理的num，如果当前num在之前被处理过则跳过（用set除重复），与当前元素匹配的剩余两个元素组成的不重复三元组只可能出现在当前num之后，还要判断第三个元素与第二个元素并不为同一个元素，map中若有重复元素，其下标值为后放入者，这样便可判断不能判断map重元素是否出现多次问题，但是这种解决方法最耗时的地方在于结果集合去重，即每个结果先排序在放入set去重。 Code:beat 14%123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Map&lt;Integer, Integer&gt; twosum = new HashMap&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums.length &lt; 3) return res; for (int i = 0; i &lt; nums.length; i++) twosum.put(nums[i], i); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Set&lt;List&lt;Integer&gt;&gt; s = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int target = 0 - nums[i]; if (set.contains(target)) continue; set.add(target); for (int j = i + 1; j &lt; nums.length; j++) &#123; if (twosum.containsKey(target - nums[j])) &#123; if (twosum.get(target - nums[j]) &gt; i + 1 &amp;&amp; twosum.get(target - nums[j]) != j) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[j]); list.add(target - nums[j]); Collections.sort(list); s.add(list); &#125; &#125; &#125; &#125; for (List&lt;Integer&gt; l : s) res.add(l); return res; &#125;&#125; Solution 2：先将数组排序，这样跳过已经处理过的元素与与上一个元素比较即可，外层循环记录待处理的num，内层循环用两个指针跳过重复元素，这样避免了结果解得去重； Code:beat 89%123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;List&lt;Integer&gt;&gt;(); int length = nums.length; Arrays.sort(nums); for (int k = 0; k &lt; length; k++) &#123; if ( nums[k] &gt; 0 )&#123; break; &#125; if ( k &gt; 0 &amp;&amp; nums[k] == nums[k-1] )&#123; continue; &#125; int i = k + 1; int j = length-1; while( i &lt; j ) &#123; int sum = nums[i] + nums[j] + nums[k]; if ( sum &lt; 0 )++i; else if ( sum &gt; 0 )--j; else &#123; lists.add(Arrays.asList(nums[i], nums[j], nums[k])); do&#123; ++i; &#125; while( i &lt; j &amp;&amp; nums[i-1] == nums[i] ); do&#123; --j; &#125; while( i &lt; j &amp;&amp; nums[j] == nums[j+1] ); &#125; &#125; &#125; return lists; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 5】Longest Palindromic Substring 最长回文子串]]></title>
    <url>%2F2018%2F08%2F12%2F%5BLeetCode%205%5DLongest%20Palindromic%20Substring%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[LeetCode 5]Longest Palindromic Substring 最长回文子串问题描述:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 说明：解集不能包含重复的子集。 示例1:123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot;也是一个有效答案。 示例2：12输入: &quot;cbbd&quot;输出: &quot;bb&quot; Solution:Solution 1:之前的考虑，最长回文字符串即字符串与倒置的字符串的最长公共字符串，但是并不正确，考虑acbca；最长公共子字符串dp解法时间复杂度为O(2)，dp[i][j]表示从i到j的最长公共子字符串，字符串p1…..pi,q1…..qj转移方程：i/j=0,dp[i][j]=0;q[i]==p[j],dp[i][j]=dp[i-1][j-1]+1;q[i]!=p[j],dp[i][j]=0; Code:wrong12345678910111213141516171819202122int n = s.length(); String sRevert = new StringBuilder(s).reverse().toString(); int maxLength = 0; int pos = 0; int[][] dp = new int[n + 1][n + 1]; for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; if (i == 0 || j == 0) dp[i][j] = 0; else if (s.charAt(i - 1) == sRevert.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; maxLength = Math.max(dp[i][j], maxLength); if (maxLength == dp[i][j]) pos = i; &#125; else dp[i][j] = 0; &#125; &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = pos - 1; i &gt; pos - maxLength - 1; i--) stringBuilder.append(s.charAt(i)); return stringBuilder.toString(); Solution 2：最长回文字符串也有dp做法，不过复杂度也为O(2)，所以我选择选择复杂度为线性的manacher算法。manacher算法是基于由中心向两边发散的算法，所以奇偶字符串处理不同，这里采用一个小技巧，在字符串首尾，及各字符间各插入一个未出现的字符使其恒为为奇字符串。定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径,设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。 假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么：12if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); 2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。 Code:beat 79%1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public String longestPalindrome(String s) &#123; StringBuilder stringBuilder = new StringBuilder(s); stringBuilder.insert(0, "#"); for (int i = 1; i &lt; s.length() * 2; i = i + 2) &#123; stringBuilder.insert(i + 1, "#"); &#125; String str = stringBuilder.toString(); int mx = 0; int id = 0; int p[] = new int[str.length()]; p[0] = 0; for (int i = 0; i &lt; str.length(); i++) &#123; if (i &lt; mx) p[i] = Math.min(mx - i, p[2 * id - i]); while (i - p[i] &gt;= 0 &amp;&amp; i + p[i] &lt;= str.length() - 1 &amp;&amp; (str.charAt(i - p[i]) == str.charAt(i + p[i]))) p[i]++; if (i + p[i] &gt; mx) &#123; mx = i + p[i]; id = i; &#125; &#125; int max = 0; for (int i = 0; i &lt; p.length; i++) &#123; max = Math.max(max, p[i]); if (max == p[i]) id = i; &#125; stringBuilder = new StringBuilder(); if (str.charAt(id) != '#') stringBuilder.append(str.charAt(id)); for (int i = 1; i &lt; max; i++) &#123; if (str.charAt(i+id) != '#') &#123; stringBuilder.append(str.charAt(i + id)); stringBuilder.insert(0, str.charAt(i + id)); &#125; &#125; return stringBuilder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 3】Longest Substring Without Repeating Characters 无重复字符的最长子串]]></title>
    <url>%2F2018%2F07%2F16%2F%5BLeetCode%203%5DLongest%20Substring%20Without%20Repeating%20Characters%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[LeetCode 3]Longest Substring Without Repeating Characters 无重复字符的最长子串Problem description:Given a string, find the length of the longest substring without repeating characters. Example:12345Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3.Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1.Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 问题描述:给定一个字符串，找出不含有重复字符的最长子串的长度。 说明：解集不能包含重复的子集。 示例:12345给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 Solution:Solution 1: 遍历char数组，put到map&lt;字符，字符下标&gt;中，若当前元素在map中，则将下表置为当前元素在map中的重复值的角标+1,继续遍历，复杂度O(N2) Code:123456789101112131415161718192021//beat 18%class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.equals("")) return 0; HashMap&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); char []array=s.toCharArray(); int max=1; for(int i=0;i&lt;array.length;i++)&#123; if(map.containsKey(array[i]))&#123; max=max&gt;map.size()?max:map.size(); i=map.get(array[i]); map.clear(); &#125;else&#123; map.put(array[i],i); &#125; &#125; max=max&gt;map.size()?max:map.size(); return max; &#125;&#125; Solution 2：（优化的滑动窗口）(i,j)作为一个窗口，让j滑动，并将j位置的字符放到map中，当map包含j位置的字符时,(未优化的滑动窗口是让i滑动，直到i，j不包含重复字符串)，i取map中j字符所在位置+1和i的最大值（考虑baab字符串，就明白为什么i取两者之间的大者），向hashmap添加重复元素时会覆盖原来的值。时间复杂度为O(n)。 Code:123456789101112131415161718//beat 67%class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.equals("")) return 0; HashMap&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); int max=1; int n=s.length(); for(int i=0,j=0;j&lt;n;j++)&#123; if(map.containsKey(s.charAt(j)))&#123; i=Math.max(map.get(s.charAt(j))+1,i); &#125; max=Math.max(max,j-i+1); map.put(s.charAt(j),j); &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器下载文件]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[浏览器下载文件solution:读取文件,设置响应头，写入返回的流前端用http请求而不能用ajax请求(JQuery的ajax函数的返回类型只有xml、text、json、html等类型，没有“流”类型，所以我们要实现ajax下载，不能够使用相应的ajax函数进行文件下载。) （前端用a标签自动点击） 123456789101112131415161718192021222324252627282930313233343536@Controller@RequestMapping("/view")public class ViewController &#123; @RequestMapping(value = "/download", method = RequestMethod.GET) public void getTemplate(HttpServletRequest request,HttpServletResponse response)throws IOException &#123; //服务器下的相对路径 String path = "WEB-INF/document/template.csv"; //通过相对路径获取真实路径 File csvFile = new File(request.getServletContext().getRealPath(path)); try&#123; ServletOutputStream out = response.getOutputStream(); FileInputStream csvInputStream = new FileInputStream(csvFile); BufferedOutputStream outputStream = new BufferedOutputStream(out); //让服务器告诉浏览器它发送的数据属于什么文件类型 response.setContentType("multipart/form-data"); //inline 和 attachment：将文件内容直接显示在页面 attachment：弹出对话框让用户下载 response.setHeader("Content-Disposition", "attachment;fileName="+"test.csv"); response.addHeader("Content-Length", String.valueOf(csvFile.length())); //设置缓冲区大小 byte []buffer = new byte[1024]; int ch = 0; while ((ch = csvInputStream.read(buffer)) != -1)&#123; outputStream.write(buffer,0,ch); &#125; outputStream.flush(); out.close(); outputStream.close(); csvInputStream.close(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 394】 Decode String 字符串解码]]></title>
    <url>%2F2018%2F06%2F01%2F%5BLeetCode%20394%5DDecode%20String%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[[LeetCode 394]Decode String 字符串解码Problem decription:Given an encoded string, return it’s decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. Example:123s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;. 题目描述：给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例:s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;. s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;. s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;. Solution：首先想到的是递归，或者是用两个栈的非递归方法，非递归的效率更高一些。一个栈用来保存数字，一个用来保存字符串，以 b3[a]2[c]d] 为例,遍历整个字符串，用t保存当前字符串，count保存当前数字，碰到字母就添加到t中，碰到数字便循环读取并转换成正确的格式，当读取到‘[’时，将count入数字栈，将当前字符入字符栈，并将t清空，当读取到‘]’时，去数字栈顶元素k与字符栈顶元素s，t=s+k个t，直至栈为空结束，t即为所求。 Code：//beat 50% class Solution { public String decodeString(String s) { Stack&lt;Integer&gt; sNum=new Stack&lt;Integer&gt;(); Stack&lt;String&gt; sStr=new Stack&lt;String&gt;(); char[] chr=s.toCharArray(); String t=""; String count=""; for(int i=0;i&lt;chr.length;i++){ if(chr[i]&gt;='0' &amp;&amp; chr[i]&lt;='9'){ while(chr[i]!='['){ count+=chr[i++]; } sNum.push(Integer.parseInt(count)); count=""; } else if(chr[i]&lt;'0' || chr[i]&gt;'9' &amp;&amp;chr[i]!=']' &amp;&amp;chr[i]!='[') t+=chr[i]; if(chr[i]=='['){ sStr.push(t); t=""; } if(chr[i]==']'){ int k=1; if(!sNum.isEmpty()){ k=sNum.pop(); String top=sStr.pop(); for(int j=0;j&lt;k;j++) top+=t; t=top; } } } return t; } }]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 377】 Combination Sum IV 组合总和 IV]]></title>
    <url>%2F2018%2F06%2F01%2F%5BLeetCode%20377%5DCombinatiion%20Sum%20IV%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20IV%2F</url>
    <content type="text"><![CDATA[[LeetCode 377]Combinatiion Sum IV 组合总和 IVProblem decription:Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example:123456789101112131415nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. Follow up:What if negative numbers are allowed in the given array?How does it change the problem?What limitation we need to add to the question to allow negative numbers? 题目描述：给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例:123456789101112131415nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 进阶：如果给定的数组中含有负数会怎么样？问题会产生什么变化？我们需要在题目中添加什么限制来允许负数的出现？ Solution：使用动态规划和递归均可，创建一个dp数组，dp[i]表示和为i的正整数组合的个数，dp[0]=1,则从i=1到target遍历，对每一个i遍历数组中每个num，若i&gt;=num,则dp[i]+=dp[i-num],表示dp[3]=dp[2]+1 或 dp[1]+2 或 dp[0]+3,将所有情况累加就是dp[3]的结果,对原数组排序可对算法进行优化，当i&lt;num后面则不用判断直接break。(后面给出递归版本) Code(动态规划)：12345678910111213141516//beat 90%class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int []dp=new int[target+1]; dp[0]=1; Arrays.sort(nums); for(int i=1;i&lt;target+1;i++)&#123; for(int num:nums)&#123; if(i&lt;num) break; dp[i]+=dp[i-num]; &#125; &#125; return dp[target]; &#125;&#125; Code(递归)：1234567891011121314//超时 class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int count=0; if(target==0) return 1; for(int num:nums)&#123; if(target&gt;=num) count+=combinationSum4(nums,target-num); &#125; return count; &#125;&#125; 123456789101112131415161718//AC beat 66.7%class Solution &#123; HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;(); public int combinationSum4(int[] nums, int target) &#123; int count=0; if(target==0) return 1; if(map.containsKey(target)) return map.get(target); for(int num:nums)&#123; if(target&gt;=num) count+=combinationSum4(nums,target-num); &#125; map.put(target,count); return count; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 70】Climbing Stairs 爬楼梯]]></title>
    <url>%2F2018%2F05%2F25%2F%5BLeetCode%2070%5DClimbing%20Stairs%20%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[[LeetCode 70]Climbing Stairs 爬楼梯Problem description:You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example:12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps 问题描述:假设你正在爬楼梯。需要 n 步你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 说明：给定 n 是一个正整数。 示例:12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 步 + 1 步2. 2 步 Solution:通过归纳可知符合斐波那契数列。 Code:12345678910111213141516171819class Solution &#123; public int climbStairs(int n) &#123; if(n==1) return 1; if(n==2) return 2; int f1=1; int f2=2; int sum=0; for(int i=2;i&lt;n;i++)&#123; sum=f1+f2; f1=f2; f2=sum; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 393】UTF-8 Validation UTF-8 编码验证]]></title>
    <url>%2F2018%2F05%2F25%2F%5BLeetCode%20393%5DUTF-8%20Validation%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[[LeetCode 393]UTF-8 Validation UTF-8 编码验证Problem description:A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules: For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one’s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.This is how the UTF-8 encoding would work: 1234567Char. number range | UTF-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx Given an array of integers representing the data, return whether it is a valid utf-8 encoding. Note:The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data. Example1:1234data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.Return true.It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character. Example2:123456data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.Return false.The first 3 bits are all one&apos;s and the 4th bit is 0 means it is a 3-bytes character.The next byte is a continuation byte which starts with 10 and that&apos;s correct.But the second continuation byte does not start with 10, so it is invalid. 问题描述:UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则： 对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。 对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 这是 UTF-8 编码的工作方式： 1234567Char. number range | UTF-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。 说明：输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。 示例1:1234data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.返回 true 。这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。 示例2:123456data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.返回 false 。前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。下一个字节是开头为 10 的延续字节，这是正确的。但第二个延续字节不以 10 开头，所以是不符合规则的。 Solution: 一开始我理解出现错误认为只有一个utf-8编码让你判断，其实是判断一组连续的编码序列，也就是若干个utf-8序列。 不用位运算的方法，也就是将每个数据通过Integer.toBinaryString(data).toCharArray来判断。 更简洁的做法是直接通过位运算来记录1的位数，过程如下: data&gt;&gt;5==0b110 右移5位如果是0b110说明有2个字节，还有1个字节需要额外判断（ 或者data &amp; 0b11000000==0b11000000,与上述功能一致 ） data&gt;&gt;4==0b1110 右移4位如果是0b1110说明有3个字节，还有2个字节需要额外判断 data&gt;&gt;3==0b11110 右移3位如果是0b110说明有4个字节，还有3个字节需要额外判断 data&gt;&gt;7=0b1表示字符为10000000情况直接返回false 如果bitSize==1，表示当前为utf—8编码的第一个字符，做以上判断 如果bitSize!=1，表示当前正在判断10开头的字符，如果data[i]&gt;&gt;6!=0b10，直接返回false Code:123456789101112131415161718192021class Solution &#123; public boolean validUtf8(int[] data) &#123; int bitSize=1; for(int i=0;i&lt;data.length;i++)&#123; if(bitSize==1)&#123; if(data[i]&gt;&gt;5==0b110) bitSize=2; else if(data[i]&gt;&gt;4==0b1110) bitSize=3; else if(data[i]&gt;&gt;3==0b11110) bitSize=4; else if(data[i]&gt;&gt;7==0b1) return false;//10000000情况 &#125;else&#123; if(data[i]&gt;&gt;6!=0b10) return false; bitSize--; &#125; &#125; return bitSize==1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 363】Max Sum of Rectangle No Larger Than K]]></title>
    <url>%2F2018%2F05%2F25%2F%5BLeetCode%20363%5D%20Max%20Sum%20of%20Rectangle%20No%20Larger%20Than%20K%20%2F</url>
    <content type="text"><![CDATA[[LeetCode 363] Max Sum of Rectangle No Larger Than KProblem description:Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Note:The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data. Example1:12345Given matrix = [ [1, 0, 1], [0, -2, 3]]k = 2 The answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2). Note: The rectangle inside the matrix must have an area &gt; 0. What if the number of rows is much larger than the number of columns? 问题描述:给定一个非空的二位矩阵和一个整数K，找到矩阵中子矩阵和最大并且不超过k的最大值。 示例1:12345给定矩阵 matrix = [ [1, 0, 1], [0, -2, 3]]k = 2 答案是2，因为矩形[[0, 1], [-2, 3]]和是2并且2 是不超过k（k=2）的最大值 。 Solution1: 这道题用纯暴力只能过95%左右，后面几个用例都会超时，所以在暴力的基础上稍微改进一下即可通过。（但不是最优解，复杂度为O(N2M2)） 用一个新矩阵保存计算值，每个值表示从点（0,0）到（i,j）的和，则计算（x1,y1）到（x2,y2）的值有以下四种情况： x1-1&lt;0 &amp;&amp; y1-1&lt;0: 说明（x1,y1）即为（0,0）点，直接返回存储矩阵中s[x2][y2]的值 x1-1&gt;=0 &amp;&amp; y1-1&lt;0: 说明y1=0， 1234561 2 3 4-------5 6 7 80 1 2 9-------计算从（1,0）到（3，3）的值 则返回s[x2][y2]-s[x1-1][y2] x1-1=0: 说明x1=0， 123451|2 3 4|5|6 7 8|0|1 2 9|计算从（0,1）到（3，3）的值 则返回s[x2][y2]-s[x2][y1-1] x1-1&gt;=0 &amp;&amp; y1-1&gt;=0: 123451 2 3 4 -------5|6 7 8|0|1 2 9| ------- 则返回s[x2][y2]-(s[x1-1][y2]+s[x2][y1-1]-s[x1-1][y1-1]) 遍历子矩阵用四层循环即可解决。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; public int maxSumSubmatrix(int[][] matrix, int k) &#123; int max=0; int row=matrix.length; int col=matrix[0].length; int [][]store=new int[row][col]; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; store[i][j]=sum(matrix,0,0,i,j); &#125; &#125; boolean flag=true; for(int x=0;x&lt;row;x++)&#123; for(int y=0;y&lt;col;y++)&#123; for(int i=x;i&lt;row;i++)&#123; for(int j=y;j&lt;col;j++)&#123; int t=sSum(store,x,y,i,j); if(t==k) return t; if(flag &amp;&amp; t&lt;k)&#123; max=t; flag=false; &#125; if(t&lt;k)&#123; max=Math.max(t,max); &#125; &#125; &#125; &#125; &#125; return max; &#125; public int sSum(int [][]s,int x1,int y1,int x2,int y2 )&#123; if(x1-1&lt;0 &amp;&amp; y1-1&lt;0) return s[x2][y2]; if(x1-1&gt;=0 &amp;&amp; y1-1&lt;0) return s[x2][y2]-s[x1-1][y2]; if(x1-1&lt;0 &amp;&amp; y1-1&gt;=0) return s[x2][y2]-s[x2][y1-1]; else&#123; return s[x2][y2]-(s[x1-1][y2]+s[x2][y1-1]-s[x1-1][y1-1]); &#125; &#125; public int sum(int [][]matrix,int x1,int y1,int x2,int y2)&#123; int res=0; for(int i=x1;i&lt;=x2;i++)&#123; for(int j=y1;j&lt;=y2;j++)&#123; res+=matrix[i][j]; &#125; &#125; return res; &#125;&#125; Solution2:动态递归解法（学习后补充）首先使用动态规划解法，这道题目可以拆分成两道题。第一点是求矩阵子矩阵最大和的动态规划思想，参考视频链接。 具体思想就是，按列扫描累加每一列然后求最大值，这样就转换为一维数组子数组求最大和的问题，这是一个简单的动态规划，dp[i]=max(dp[i-1],array[i]); 第二点就是一维数组子数组最大和有可能大于给定的k，所以问题转换为求一维数组子数组和不大于k的最大值： 通过累加和可以求得任意区间的和，例如，cum数组为累加和数组，cum[i]表示从cum[0]到cum[i]的和，则区间（i,j）的和可表示为cum[j]-cum[i-1]; 这里还要借助TreeSet因为treeset中ceiling方法可以求出大于或等于给定的元素的最小元素，也就是说我们在累加过程中去比较max和set.ceiling(sum-k)的大小即可，由于treeset查询这一步时间复杂度是O(logn),所以总的时间复杂度是O(N2*M*log(M)),如果列数远远大于行数，可以按照行扫描。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int maxSumSubmatrix(int[][] matrix, int k) &#123; int rowSize=matrix.length; int colSize=matrix[0].length; int maxSum=Integer.MIN_VALUE; int currentSum=0; // int maxLeft=0; // int maxRight=0; // int maxUp=0; // int maxDown=0; int []rowArray=new int[rowSize]; for(int left=0;left&lt;colSize;left++)&#123; for(int right=left;right&lt;colSize;right++)&#123; for(int i=0;i&lt;rowSize;i++)&#123; rowArray[i]+=matrix[i][right]; &#125; currentSum=maxSubArray(rowArray,k); if(currentSum==k) return k; if(currentSum&lt;k) maxSum=Math.max(currentSum,maxSum); &#125; for(int i=0;i&lt;rowSize;i++)&#123; rowArray[i]=0; &#125; &#125; return maxSum; &#125; public int maxSubArray(int []a,int k)&#123; TreeSet&lt;Integer&gt; set=new TreeSet&lt;Integer&gt;(); int sum=0; int max=Integer.MIN_VALUE; set.add(0); for(int i=0;i&lt;a.length;i++)&#123; sum+=a[i]; Integer v=set.ceiling(sum-k);//返回大于或等于给定的元素的最小元素，或null if(v!=null)&#123; max=Math.max(sum-v,max); &#125; set.add(sum); &#125; return max; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 78】Subsets 子集]]></title>
    <url>%2F2018%2F05%2F24%2F%5BLeetCode%2078%5DSubsets%20%E5%AD%90%E9%9B%86%2F</url>
    <content type="text"><![CDATA[[LeetCode 78]Subsets 子集Problem description:Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example:123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 问题描述:给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] Solution:Solution 1: 一个集合有n个元素，则其有2n的子集。 列出从0到2n-1的所有二进制，0表示不取对应元素，1表示取对应元素，即可得出所有子集。 123456789 1 2 3 Subset0 0 0 0 []1 0 0 1 32 0 1 0 23 0 1 1 234 1 0 0 15 1 0 1 136 1 1 0 127 1 1 1 123 Code:1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); int count=pow(2,nums.length); for(int i=0;i&lt;count;i++)&#123; char []bit=Integer.toBinaryString(i).toCharArray(); ArrayList&lt;Integer&gt; temp=new ArrayList&lt;Integer&gt;(); //从数组最后一位开始判断 for(int j=bit.length-1,k=nums.length-1;j&gt;=0;j--,k--)&#123; if(bit[j]=='1') temp.add(nums[k]); &#125; Collections.sort(temp); res.add(temp); temp=new ArrayList&lt;Integer&gt;(); &#125; return res; &#125; public int pow(int i,int n)&#123; int res=1; for(int k=0;k&lt;n;k++)&#123; res*=i; &#125; return res; &#125;&#125; Solution 2：深度优先算法，由于原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况，所以可以构造一棵二叉树，左子树表示选择该元素，右子树表示不选择，最终的叶节点就是所有子集合，树的结构如下： 12345678910 [] / \ / \ / \ [1] [] / \ / \ / \ / \ [1 2] [1] [2] [] / \ / \ / \ / \[1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] [] Code:123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; temp=new ArrayList&lt;Integer&gt;(); getSubList(nums,res,temp,0); return res; &#125; public void getSubList(int []nums,List&lt;List&lt;Integer&gt;&gt; res,ArrayList&lt;Integer&gt; temp,int pos)&#123; res.add(new ArrayList(temp));//注意要new一个ArrayList对象 for(int i=pos;i&lt;nums.length;i++)&#123; temp.add(nums[i]);//选择元素nums[i] getSubList(nums,res,temp,i+1);//下一个元素 temp.remove(temp.size()-1);//不选择nums[i] &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 48】Rotate Image 旋转图像]]></title>
    <url>%2F2018%2F05%2F24%2F%5BLeetCode%2048%5DRotate%20Image%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[[LeetCode 48]Rotate Image 旋转图像Problem description:You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note:You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1:12345678910111213Given input matrix =[ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2:123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]],rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 问题描述:给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明:你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例1:12345678910111213给定 matrix =[ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例2:123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]],原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] Solution:将矩阵沿着主对角线翻转一次，再沿着对称线旋转一次即可。 Code:123456789101112131415161718192021222324252627class Solution &#123; public void rotate(int[][] matrix) &#123; int n=matrix[0].length; int num=1; //沿着主对角线翻转 for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;num;j++)&#123; int temp=matrix[i][j]; matrix[i][j]=matrix[j][i]; matrix[j][i]=temp; &#125; num++; &#125; //沿着对称轴线翻转 for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n/2;j++)&#123; int temp=matrix[i][j]; matrix[i][j]=matrix[i][n-j-1]; matrix[i][n-j-1]=temp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 01】 Two Sum 两数之和]]></title>
    <url>%2F2018%2F05%2F24%2F%5BLeetCode%2001%5DTwo%20Sum%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[LeetCode 01]Two Sum 两数之和Problem decription:Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 题目描述：给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例:123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] Solution： 排序数组，用两个头尾指针遍历即可，排序复杂度为O(nlogn),空间复杂度为O(1)； 利用map，以&lt;值,数组下标&gt;方式储存，再遍历数组即可； 这里采用第二种解法，要注意考虑数组中包含重复值的情况，在加入map的过程中要做判断； Code：123456789101112131415161718192021222324252627import java.util.HashMap;class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; h=new HashMap&lt;Integer,Integer&gt;(); int []result=new int[2]; boolean flag=true; for(int i=0;i&lt;nums.length;i++)&#123; if(h.containsKey(nums[i]) &amp;&amp; 2*nums[i]==target)&#123; result[0]=h.get(nums[i]); result[1]=i; flag=false;// 如果在加入时的重复值即为结果，则后面无需执行 &#125; h.put(nums[i],i); &#125; for(int j=0;j&lt;nums.length;j++)&#123; if(h.containsKey(target-nums[j]) &amp;&amp; target-nums[j]!=nums[j] &amp;&amp; flag)&#123; result[0]=j; result[1]=h.get(target-nums[j]); break; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基本语法]]></title>
    <url>%2F2018%2F05%2F22%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[为了顺畅的在github pages上书写自己的blog，需要学习一些基本的MarkDown语法。 常用语法规则标题总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。快捷键：command + 1/2/3/4/5/6 换行只需在行末加两个空格键和一个回车键即可换行。快捷键：control + 回车键 文本样式123456加粗 - 快捷键：command + B 斜体 - 快捷键：command + I 删除线 - 快捷键：command + U 底纹 - 快捷键：command + K 下划线 - html：&lt;u&gt;text&lt;/u&gt;分割线 - 用*** 加粗 : hello* 斜体 * :hello~~ 删除线 ~~ :hello` 底纹 ` :hello分割线： 列表列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 无序列表 a b c 有序列表 a b c 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可 this is a quote 图片与链接图片为：![]() 链接为：[]() 在线插入：插入图片的地址需要图床，这里推荐围脖图床修复计划，生成URL 本地插入：![](本地路径) 插入图片 代码块使用三个`包裹代码即可 ,注意后面不要跟空格，hexo在生成网页时代码块之间匹配会出现问题 123var a = "hello world";var b = "hello world";]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github pages + hexo搭建博客]]></title>
    <url>%2F2018%2F05%2F22%2F%E4%BD%BF%E7%94%A8github%20pages%20%2B%20hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 目前比较热门的两种方式就是使用静态博客框架 jekyll 或者 hexo，相对于jekyll，hexo主题丰富，第三方插件优秀，配置简单，最主要的一点，hexo的开发文档阅读感受较jekyll来说更舒服。 一.环境搭建 官方文档非常详细 hexo documents 这里以MacOs为例 github账号注册地址 安装Node.js cURL:$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget:$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后重启终端：$ nvm install stable 这里推荐下载安装程序来安装 安装git$ brew install git 安装 Hexo$ npm install -g hexo-cli 二.建站123$ hexo init &lt;folderName&gt;$ cd &lt;folderName&gt;$ npm install 安装完成后文件目录结构如下： 12345678├── \_config.yml├── package.json├── scaffolds├── source| ├── \_drafts| └── \_posts└── themes 你可以在_config.yml中配置大部分网站设置。 其他一些Hexo常用命令： 1234567hexo n # 新建文章，在\source\_posts文件夹里hexo new page # 新建页面，比如想在导航栏新增一个“关于我”的页面hexo clean # 清除本地的数据库和生成的public文件夹hexo g # 生成博客文件hexo s # 运行在本地浏览器，可当预览使用hexo d # 部署博客到Github等 三.创建Repo 新建一个repo，注意名称一定是your_username.github.io这样的格式。 进入刚新建的仓库，点击Setting，一直拖到最下面，选择Automatic Page Generator，随便选个主题然后发布即可。 在站点_config.yml文件中任意位置添加以下代码段： 12345deploy: type: git # 填上你自己的仓库名，注意后面有`.git` repository: git@github.com:your_username/your_username.github.io.git branch: master 注意每个：后面都要跟一个空格！ 安装部署所需：$ npm install hexo-deployer-git --save 四.主题 创建 Hexo 主题非常容易，您只要在 themes 文件夹内，新增一个任意名称的文件夹，并修改 _config.yml 内的 theme 设定，即可切换主题。一个主题可能会有以下的结构： 123456.├── \_config.yml(配置是无需重启服务器会自动更新)├── languages├── layout├── scripts└── source 这里推荐使用最多的nexT 主题 五.新建页面新建分类页面：hexo new page categories 打开../source/categories/index.md 编辑相对应的type 123456---title: 分类date: 2018-05-21 22:00:35type: &quot;categories&quot;comments: false--- 在站点_config.yml中更改menu下代码，如果没有添加 categories: /categories/ 新建导航默认导航栏只有首页、归档、标签、分类四项。如果想增加其他如C++、随笔等。需要打开\themes\next_config.yml找到如下 123456789101112#When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / categories: /categories tags: /tags archives: /archives #这里是新增的，Coding是一级目录，C是二级目录，同理随笔是一级目录 c++: /categories/Coding/C/ python: /categories/Coding/Python/ essay: /categories/随笔/ #注意这里没有/categories about: /about that‘s all！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
</search>
