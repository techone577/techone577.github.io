<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Jdk动态代理实现自定义拦截器]]></title>
    <url>%2F2018%2F08%2F22%2F%E4%BD%BF%E7%94%A8Jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[使用Jdk动态代理实现自定义拦截器接口：public interface IUser { public String getName(); } 实现类：public class User implements IUser { private String name; public User(String name){ this.name=name; } @Override public String getName () { return name; } } 自定义拦截器接口：public interface Interceptor { boolean before(Object proxy, Object target, Method method,Object []args); void around (Object proxy,Object target,Method method,Object []args); void after(Object proxy, Object target, Method method, Object []args); } 拦截器实现类： (在调用方法前做了个简单的属性校验)这里可以实现多个拦截器实现责任链模式，target的代理是proxy1，proxy1的代理是proxy2，proxy2的代理是proxy3，这样就可以实现顺序拦截（好处是可以再责任链上任意位置添加拦截，缺点是代理和反射太多性能不高） public class MyInterceptor implements Interceptor { @Override public boolean before (Object proxy, Object target, Method method, Object[] args) { System.out.println("before"); if (checkProperties(target)) return true; return false; } @Override public void around (Object proxy, Object target, Method method, Object[] args) { System.out.println("around"); } @Override public void after (Object proxy, Object target, Method method, Object[] args) { System.out.println("After"); } private boolean checkProperties (Object object) { Field[] fields = object.getClass().getDeclaredFields(); try { for (Field field : fields) { field.setAccessible(true); if (field.get(object).equals("")) return false; } } catch (Exception e) { } return true; } } 实现InvocationHandler:流程如下： public class MyInvocationHandler implements InvocationHandler { private Object target; private Class clazz; public MyInvocationHandler(Object t,Class c){ this.target = t; this.clazz = c; } public static Object bind(Object target,Class clazz){ return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new MyInvocationHandler(target,clazz)); } @Override public Object invoke (Object proxy, Method method, Object[] args) throws Throwable { if(this.clazz==null) return method.invoke(target,args); Object result=null; Interceptor interceptor = (Interceptor) clazz.newInstance(); if(interceptor.before(proxy,target,method,args)){ result = method.invoke(target,args); }else{ interceptor.around(proxy,target,method,args); } interceptor.after(proxy,target,method,args); return result; } } 测试：public class test { public static void main(String []args){ IUser u = new User(""); IUser proxy = (IUser)MyInvocationHandler.bind(u,MyInterceptor.class); proxy.getName(); } } 运行结果:]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 784】Letter Case Permutation字母大小写全排列]]></title>
    <url>%2F2018%2F08%2F21%2F%5BLeetCode%20784%5DLetter%20Case%20Permutation%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[[LeetCode 784]Letter Case Permutation字母大小写全排列问题描述:给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。 示例:123456789示例:输入: S = &quot;a1b2&quot;输出: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]输入: S = &quot;3z4&quot;输出: [&quot;3z4&quot;, &quot;3Z4&quot;]输入: S = &quot;12345&quot;输出: [&quot;12345&quot;] 注意：S 的长度不超过12。S 仅由数字和字母组成。 Solution:Solution : 深度优先搜索即可解决 Code:beat 84%1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public static List&lt;String&gt; letterCasePermutation (String S) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); letterCasePermutationHelper(res, S, 0, new StringBuilder()); return res; &#125; private static void letterCasePermutationHelper (List&lt;String&gt; list, String s, int pos, StringBuilder sb) &#123; for (int i = pos; i &lt; s.length(); i++) &#123; if ('0' &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= '9') sb.append(s.charAt(i)); else&#123; //添加原来的字母 sb.append(s.charAt(i)); StringBuilder t = new StringBuilder(sb.toString()); letterCasePermutationHelper(list, s, i + 1, sb); sb = t; //添加转变后的字母 sb.deleteCharAt(i); sb.append(transLeeterCase(s.charAt(i))); &#125; &#125; list.add(sb.toString()); &#125; private static char transLeeterCase (char letter) &#123; char res = ' '; if ('a' &lt;= letter &amp;&amp; letter &lt;= 'z') &#123; res = (char) (letter-('a'-'A')); &#125; else if ('A' &lt;= letter &amp;&amp; letter &lt;= 'Z') &#123; res = (char) (letter+'a'-'A'); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jdk动态代理和Cglib动态代理]]></title>
    <url>%2F2018%2F08%2F20%2FJdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Jdk动态代理和Cglib动态代理Jdk动态代理：只能为接口实现代理 接口： 1234public interface IUser &#123; String getName(String name);&#125; 实现类： 123456public class User implements IUser &#123; @Override public String getName (String name) &#123; return name; &#125;&#125; 实现InvocationHandler接口： 123456789101112131415import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler &#123; private Object target; public MyInvocationHandler(Object target)&#123; this.target = target; &#125; @Override public Object invoke (Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.print(method.getName()+"\n"); return method.invoke(target,args); &#125;&#125; 调用： 1234567891011import java.lang.reflect.Proxy;public class test &#123; public static void main(String []args)&#123; IUser u = new User(); MyInvocationHandler invocationHandler = new MyInvocationHandler(u); IUser proxy = (IUser) Proxy.newProxyInstance(u.getClass().getClassLoader(),u.getClass().getInterfaces(),invocationHandler); System.out.print(proxy.getName("hello")); &#125;&#125; cglib动态代理：为类生成代理，被代理类无需实现接口，引入jar包版本asm3.31对应cglib-2.2.2（对应其他版本cglib可能会有冲突，） 被代理类不能用final修饰，要生成子类 被代理类： 123456public class User &#123; public String getName(String name)&#123; return name; &#125;&#125; 实现MethodInterceptor接口： 12345678910111213141516171819202122232425import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class UserCglib implements MethodInterceptor &#123; private Object target; public Object getInstance(Object target)&#123; this.target = target; //创建加强器，用来创建动态代理类 Enhancer enhancer = new Enhancer(); //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类） enhancer.setSuperclass(this.target.getClass()); //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦 enhancer.setCallback(this); // 创建动态代理类对象并返回 return enhancer.create(); &#125; // 实现回调方法 @Override public Object intercept (Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return methodProxy.invokeSuper(o,objects); &#125; 调用： 123456789public class test &#123; public static void main(String []args)&#123; User user = new User(); UserCglib userCglib = new UserCglib(); User proxy = (User)userCglib.getInstance(user); System.out.print(proxy.getName("hello")); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 15】3sum 三数之和]]></title>
    <url>%2F2018%2F08%2F20%2F%E3%80%90LeetCode%2015%E3%80%913sum%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[【LeetCode 15】3sum 三数之和问题描述:给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 说明：答案中不可以包含重复的三元组。 示例:1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] Solution:Solution 1: 首先想到的是以2sum为基础的利用集合解决的方法，用一个map存储所有元素，但是不能判断map重元素是否出现多次，两层循环，外层循环即为待处理的num，如果当前num在之前被处理过则跳过（用set除重复），与当前元素匹配的剩余两个元素组成的不重复三元组只可能出现在当前num之后，还要判断第三个元素与第二个元素并不为同一个元素，map中若有重复元素，其下标值为后放入者，这样便可判断不能判断map重元素是否出现多次问题，但是这种解决方法最耗时的地方在于结果集合去重，即每个结果先排序在放入set去重。 Code:beat 14%123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Map&lt;Integer, Integer&gt; twosum = new HashMap&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums.length &lt; 3) return res; for (int i = 0; i &lt; nums.length; i++) twosum.put(nums[i], i); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Set&lt;List&lt;Integer&gt;&gt; s = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int target = 0 - nums[i]; if (set.contains(target)) continue; set.add(target); for (int j = i + 1; j &lt; nums.length; j++) &#123; if (twosum.containsKey(target - nums[j])) &#123; if (twosum.get(target - nums[j]) &gt; i + 1 &amp;&amp; twosum.get(target - nums[j]) != j) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[j]); list.add(target - nums[j]); Collections.sort(list); s.add(list); &#125; &#125; &#125; &#125; for (List&lt;Integer&gt; l : s) res.add(l); return res; &#125;&#125; Solution 2：先将数组排序，这样跳过已经处理过的元素与与上一个元素比较即可，外层循环记录待处理的num，内层循环用两个指针跳过重复元素，这样避免了结果解得去重； Code:beat 89%123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;List&lt;Integer&gt;&gt;(); int length = nums.length; Arrays.sort(nums); for (int k = 0; k &lt; length; k++) &#123; if ( nums[k] &gt; 0 )&#123; break; &#125; if ( k &gt; 0 &amp;&amp; nums[k] == nums[k-1] )&#123; continue; &#125; int i = k + 1; int j = length-1; while( i &lt; j ) &#123; int sum = nums[i] + nums[j] + nums[k]; if ( sum &lt; 0 )++i; else if ( sum &gt; 0 )--j; else &#123; lists.add(Arrays.asList(nums[i], nums[j], nums[k])); do&#123; ++i; &#125; while( i &lt; j &amp;&amp; nums[i-1] == nums[i] ); do&#123; --j; &#125; while( i &lt; j &amp;&amp; nums[j] == nums[j+1] ); &#125; &#125; &#125; return lists; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 5】Longest Palindromic Substring 最长回文子串]]></title>
    <url>%2F2018%2F08%2F12%2F%5BLeetCode%205%5DLongest%20Palindromic%20Substring%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[LeetCode 5]Longest Palindromic Substring 最长回文子串问题描述:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 说明：解集不能包含重复的子集。 示例1:123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot;也是一个有效答案。 示例2：12输入: &quot;cbbd&quot;输出: &quot;bb&quot; Solution:Solution 1:之前的考虑，最长回文字符串即字符串与倒置的字符串的最长公共字符串，但是并不正确，考虑acbca；最长公共子字符串dp解法时间复杂度为O(2)，dp[i][j]表示从i到j的最长公共子字符串，字符串p1…..pi,q1…..qj转移方程：i/j=0,dp[i][j]=0;q[i]==p[j],dp[i][j]=dp[i-1][j-1]+1;q[i]!=p[j],dp[i][j]=0; Code:wrong12345678910111213141516171819202122int n = s.length(); String sRevert = new StringBuilder(s).reverse().toString(); int maxLength = 0; int pos = 0; int[][] dp = new int[n + 1][n + 1]; for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; if (i == 0 || j == 0) dp[i][j] = 0; else if (s.charAt(i - 1) == sRevert.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; maxLength = Math.max(dp[i][j], maxLength); if (maxLength == dp[i][j]) pos = i; &#125; else dp[i][j] = 0; &#125; &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = pos - 1; i &gt; pos - maxLength - 1; i--) stringBuilder.append(s.charAt(i)); return stringBuilder.toString(); Solution 2：最长回文字符串也有dp做法，不过复杂度也为O(2)，所以我选择选择复杂度为线性的manacher算法。manacher算法是基于由中心向两边发散的算法，所以奇偶字符串处理不同，这里采用一个小技巧，在字符串首尾，及各字符间各插入一个未出现的字符使其恒为为奇字符串。定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径,设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。 假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么：12if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); 2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。 Code:beat 79%1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public String longestPalindrome(String s) &#123; StringBuilder stringBuilder = new StringBuilder(s); stringBuilder.insert(0, "#"); for (int i = 1; i &lt; s.length() * 2; i = i + 2) &#123; stringBuilder.insert(i + 1, "#"); &#125; String str = stringBuilder.toString(); int mx = 0; int id = 0; int p[] = new int[str.length()]; p[0] = 0; for (int i = 0; i &lt; str.length(); i++) &#123; if (i &lt; mx) p[i] = Math.min(mx - i, p[2 * id - i]); while (i - p[i] &gt;= 0 &amp;&amp; i + p[i] &lt;= str.length() - 1 &amp;&amp; (str.charAt(i - p[i]) == str.charAt(i + p[i]))) p[i]++; if (i + p[i] &gt; mx) &#123; mx = i + p[i]; id = i; &#125; &#125; int max = 0; for (int i = 0; i &lt; p.length; i++) &#123; max = Math.max(max, p[i]); if (max == p[i]) id = i; &#125; stringBuilder = new StringBuilder(); if (str.charAt(id) != '#') stringBuilder.append(str.charAt(id)); for (int i = 1; i &lt; max; i++) &#123; if (str.charAt(i+id) != '#') &#123; stringBuilder.append(str.charAt(i + id)); stringBuilder.insert(0, str.charAt(i + id)); &#125; &#125; return stringBuilder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 3】Longest Substring Without Repeating Characters 无重复字符的最长子串]]></title>
    <url>%2F2018%2F07%2F16%2F%5BLeetCode%203%5DLongest%20Substring%20Without%20Repeating%20Characters%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[[LeetCode 3]Longest Substring Without Repeating Characters 无重复字符的最长子串Problem description:Given a string, find the length of the longest substring without repeating characters. Example:12345Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3.Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1.Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 问题描述:给定一个字符串，找出不含有重复字符的最长子串的长度。 说明：解集不能包含重复的子集。 示例:12345给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 Solution:Solution 1: 遍历char数组，put到map&lt;字符，字符下标&gt;中，若当前元素在map中，则将下表置为当前元素在map中的重复值的角标+1,继续遍历，复杂度O(N2) Code:123456789101112131415161718192021//beat 18%class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.equals("")) return 0; HashMap&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); char []array=s.toCharArray(); int max=1; for(int i=0;i&lt;array.length;i++)&#123; if(map.containsKey(array[i]))&#123; max=max&gt;map.size()?max:map.size(); i=map.get(array[i]); map.clear(); &#125;else&#123; map.put(array[i],i); &#125; &#125; max=max&gt;map.size()?max:map.size(); return max; &#125;&#125; Solution 2：（优化的滑动窗口）(i,j)作为一个窗口，让j滑动，并将j位置的字符放到map中，当map包含j位置的字符时,(未优化的滑动窗口是让i滑动，直到i，j不包含重复字符串)，i取map中j字符所在位置+1和i的最大值（考虑baab字符串，就明白为什么i取两者之间的大者），向hashmap添加重复元素时会覆盖原来的值。时间复杂度为O(n)。 Code:123456789101112131415161718//beat 67%class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.equals("")) return 0; HashMap&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); int max=1; int n=s.length(); for(int i=0,j=0;j&lt;n;j++)&#123; if(map.containsKey(s.charAt(j)))&#123; i=Math.max(map.get(s.charAt(j))+1,i); &#125; max=Math.max(max,j-i+1); map.put(s.charAt(j),j); &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器下载文件]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[浏览器下载文件solution:读取文件,设置响应头，写入返回的流前端用http请求而不能用ajax请求(JQuery的ajax函数的返回类型只有xml、text、json、html等类型，没有“流”类型，所以我们要实现ajax下载，不能够使用相应的ajax函数进行文件下载。) （前端用a标签自动点击） 123456789101112131415161718192021222324252627282930313233343536@Controller@RequestMapping("/view")public class ViewController &#123; @RequestMapping(value = "/download", method = RequestMethod.GET) public void getTemplate(HttpServletRequest request,HttpServletResponse response)throws IOException &#123; //服务器下的相对路径 String path = "WEB-INF/document/template.csv"; //通过相对路径获取真实路径 File csvFile = new File(request.getServletContext().getRealPath(path)); try&#123; ServletOutputStream out = response.getOutputStream(); FileInputStream csvInputStream = new FileInputStream(csvFile); BufferedOutputStream outputStream = new BufferedOutputStream(out); //让服务器告诉浏览器它发送的数据属于什么文件类型 response.setContentType("multipart/form-data"); //inline 和 attachment：将文件内容直接显示在页面 attachment：弹出对话框让用户下载 response.setHeader("Content-Disposition", "attachment;fileName="+"test.csv"); response.addHeader("Content-Length", String.valueOf(csvFile.length())); //设置缓冲区大小 byte []buffer = new byte[1024]; int ch = 0; while ((ch = csvInputStream.read(buffer)) != -1)&#123; outputStream.write(buffer,0,ch); &#125; outputStream.flush(); out.close(); outputStream.close(); csvInputStream.close(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 394】 Decode String 字符串解码]]></title>
    <url>%2F2018%2F06%2F01%2F%5BLeetCode%20394%5DDecode%20String%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[[LeetCode 394]Decode String 字符串解码Problem decription:Given an encoded string, return it’s decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. Example:123s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;. 题目描述：给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例:s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;. s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;. s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;. Solution：首先想到的是递归，或者是用两个栈的非递归方法，非递归的效率更高一些。一个栈用来保存数字，一个用来保存字符串，以 b3[a]2[c]d] 为例,遍历整个字符串，用t保存当前字符串，count保存当前数字，碰到字母就添加到t中，碰到数字便循环读取并转换成正确的格式，当读取到‘[’时，将count入数字栈，将当前字符入字符栈，并将t清空，当读取到‘]’时，去数字栈顶元素k与字符栈顶元素s，t=s+k个t，直至栈为空结束，t即为所求。 Code：//beat 50% class Solution { public String decodeString(String s) { Stack&lt;Integer&gt; sNum=new Stack&lt;Integer&gt;(); Stack&lt;String&gt; sStr=new Stack&lt;String&gt;(); char[] chr=s.toCharArray(); String t=""; String count=""; for(int i=0;i&lt;chr.length;i++){ if(chr[i]&gt;='0' &amp;&amp; chr[i]&lt;='9'){ while(chr[i]!='['){ count+=chr[i++]; } sNum.push(Integer.parseInt(count)); count=""; } else if(chr[i]&lt;'0' || chr[i]&gt;'9' &amp;&amp;chr[i]!=']' &amp;&amp;chr[i]!='[') t+=chr[i]; if(chr[i]=='['){ sStr.push(t); t=""; } if(chr[i]==']'){ int k=1; if(!sNum.isEmpty()){ k=sNum.pop(); String top=sStr.pop(); for(int j=0;j&lt;k;j++) top+=t; t=top; } } } return t; } }]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 377】 Combination Sum IV 组合总和 IV]]></title>
    <url>%2F2018%2F06%2F01%2F%5BLeetCode%20377%5DCombinatiion%20Sum%20IV%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20IV%2F</url>
    <content type="text"><![CDATA[[LeetCode 377]Combinatiion Sum IV 组合总和 IVProblem decription:Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example:123456789101112131415nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. Follow up:What if negative numbers are allowed in the given array?How does it change the problem?What limitation we need to add to the question to allow negative numbers? 题目描述：给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例:123456789101112131415nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 进阶：如果给定的数组中含有负数会怎么样？问题会产生什么变化？我们需要在题目中添加什么限制来允许负数的出现？ Solution：使用动态规划和递归均可，创建一个dp数组，dp[i]表示和为i的正整数组合的个数，dp[0]=1,则从i=1到target遍历，对每一个i遍历数组中每个num，若i&gt;=num,则dp[i]+=dp[i-num],表示dp[3]=dp[2]+1 或 dp[1]+2 或 dp[0]+3,将所有情况累加就是dp[3]的结果,对原数组排序可对算法进行优化，当i&lt;num后面则不用判断直接break。(后面给出递归版本) Code(动态规划)：12345678910111213141516//beat 90%class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int []dp=new int[target+1]; dp[0]=1; Arrays.sort(nums); for(int i=1;i&lt;target+1;i++)&#123; for(int num:nums)&#123; if(i&lt;num) break; dp[i]+=dp[i-num]; &#125; &#125; return dp[target]; &#125;&#125; Code(递归)：1234567891011121314//超时 class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int count=0; if(target==0) return 1; for(int num:nums)&#123; if(target&gt;=num) count+=combinationSum4(nums,target-num); &#125; return count; &#125;&#125; 123456789101112131415161718//AC beat 66.7%class Solution &#123; HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;(); public int combinationSum4(int[] nums, int target) &#123; int count=0; if(target==0) return 1; if(map.containsKey(target)) return map.get(target); for(int num:nums)&#123; if(target&gt;=num) count+=combinationSum4(nums,target-num); &#125; map.put(target,count); return count; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 70】Climbing Stairs 爬楼梯]]></title>
    <url>%2F2018%2F05%2F25%2F%5BLeetCode%2070%5DClimbing%20Stairs%20%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[[LeetCode 70]Climbing Stairs 爬楼梯Problem description:You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example:12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps 问题描述:假设你正在爬楼梯。需要 n 步你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 说明：给定 n 是一个正整数。 示例:12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 步 + 1 步2. 2 步 Solution:通过归纳可知符合斐波那契数列。 Code:12345678910111213141516171819class Solution &#123; public int climbStairs(int n) &#123; if(n==1) return 1; if(n==2) return 2; int f1=1; int f2=2; int sum=0; for(int i=2;i&lt;n;i++)&#123; sum=f1+f2; f1=f2; f2=sum; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 363】Max Sum of Rectangle No Larger Than K]]></title>
    <url>%2F2018%2F05%2F25%2F%5BLeetCode%20363%5D%20Max%20Sum%20of%20Rectangle%20No%20Larger%20Than%20K%20%2F</url>
    <content type="text"><![CDATA[[LeetCode 363] Max Sum of Rectangle No Larger Than KProblem description:Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Note:The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data. Example1:12345Given matrix = [ [1, 0, 1], [0, -2, 3]]k = 2 The answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2). Note: The rectangle inside the matrix must have an area &gt; 0. What if the number of rows is much larger than the number of columns? 问题描述:给定一个非空的二位矩阵和一个整数K，找到矩阵中子矩阵和最大并且不超过k的最大值。 示例1:12345给定矩阵 matrix = [ [1, 0, 1], [0, -2, 3]]k = 2 答案是2，因为矩形[[0, 1], [-2, 3]]和是2并且2 是不超过k（k=2）的最大值 。 Solution1: 这道题用纯暴力只能过95%左右，后面几个用例都会超时，所以在暴力的基础上稍微改进一下即可通过。（但不是最优解，复杂度为O(N2M2)） 用一个新矩阵保存计算值，每个值表示从点（0,0）到（i,j）的和，则计算（x1,y1）到（x2,y2）的值有以下四种情况： x1-1&lt;0 &amp;&amp; y1-1&lt;0: 说明（x1,y1）即为（0,0）点，直接返回存储矩阵中s[x2][y2]的值 x1-1&gt;=0 &amp;&amp; y1-1&lt;0: 说明y1=0， 1234561 2 3 4-------5 6 7 80 1 2 9-------计算从（1,0）到（3，3）的值 则返回s[x2][y2]-s[x1-1][y2] x1-1=0: 说明x1=0， 123451|2 3 4|5|6 7 8|0|1 2 9|计算从（0,1）到（3，3）的值 则返回s[x2][y2]-s[x2][y1-1] x1-1&gt;=0 &amp;&amp; y1-1&gt;=0: 123451 2 3 4 -------5|6 7 8|0|1 2 9| ------- 则返回s[x2][y2]-(s[x1-1][y2]+s[x2][y1-1]-s[x1-1][y1-1]) 遍历子矩阵用四层循环即可解决。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; public int maxSumSubmatrix(int[][] matrix, int k) &#123; int max=0; int row=matrix.length; int col=matrix[0].length; int [][]store=new int[row][col]; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; store[i][j]=sum(matrix,0,0,i,j); &#125; &#125; boolean flag=true; for(int x=0;x&lt;row;x++)&#123; for(int y=0;y&lt;col;y++)&#123; for(int i=x;i&lt;row;i++)&#123; for(int j=y;j&lt;col;j++)&#123; int t=sSum(store,x,y,i,j); if(t==k) return t; if(flag &amp;&amp; t&lt;k)&#123; max=t; flag=false; &#125; if(t&lt;k)&#123; max=Math.max(t,max); &#125; &#125; &#125; &#125; &#125; return max; &#125; public int sSum(int [][]s,int x1,int y1,int x2,int y2 )&#123; if(x1-1&lt;0 &amp;&amp; y1-1&lt;0) return s[x2][y2]; if(x1-1&gt;=0 &amp;&amp; y1-1&lt;0) return s[x2][y2]-s[x1-1][y2]; if(x1-1&lt;0 &amp;&amp; y1-1&gt;=0) return s[x2][y2]-s[x2][y1-1]; else&#123; return s[x2][y2]-(s[x1-1][y2]+s[x2][y1-1]-s[x1-1][y1-1]); &#125; &#125; public int sum(int [][]matrix,int x1,int y1,int x2,int y2)&#123; int res=0; for(int i=x1;i&lt;=x2;i++)&#123; for(int j=y1;j&lt;=y2;j++)&#123; res+=matrix[i][j]; &#125; &#125; return res; &#125;&#125; Solution2:动态递归解法（学习后补充）首先使用动态规划解法，这道题目可以拆分成两道题。第一点是求矩阵子矩阵最大和的动态规划思想，参考视频链接。 具体思想就是，按列扫描累加每一列然后求最大值，这样就转换为一维数组子数组求最大和的问题，这是一个简单的动态规划，dp[i]=max(dp[i-1],array[i]); 第二点就是一维数组子数组最大和有可能大于给定的k，所以问题转换为求一维数组子数组和不大于k的最大值： 通过累加和可以求得任意区间的和，例如，cum数组为累加和数组，cum[i]表示从cum[0]到cum[i]的和，则区间（i,j）的和可表示为cum[j]-cum[i-1]; 这里还要借助TreeSet因为treeset中ceiling方法可以求出大于或等于给定的元素的最小元素，也就是说我们在累加过程中去比较max和set.ceiling(sum-k)的大小即可，由于treeset查询这一步时间复杂度是O(logn),所以总的时间复杂度是O(N2*M*log(M)),如果列数远远大于行数，可以按照行扫描。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int maxSumSubmatrix(int[][] matrix, int k) &#123; int rowSize=matrix.length; int colSize=matrix[0].length; int maxSum=Integer.MIN_VALUE; int currentSum=0; // int maxLeft=0; // int maxRight=0; // int maxUp=0; // int maxDown=0; int []rowArray=new int[rowSize]; for(int left=0;left&lt;colSize;left++)&#123; for(int right=left;right&lt;colSize;right++)&#123; for(int i=0;i&lt;rowSize;i++)&#123; rowArray[i]+=matrix[i][right]; &#125; currentSum=maxSubArray(rowArray,k); if(currentSum==k) return k; if(currentSum&lt;k) maxSum=Math.max(currentSum,maxSum); &#125; for(int i=0;i&lt;rowSize;i++)&#123; rowArray[i]=0; &#125; &#125; return maxSum; &#125; public int maxSubArray(int []a,int k)&#123; TreeSet&lt;Integer&gt; set=new TreeSet&lt;Integer&gt;(); int sum=0; int max=Integer.MIN_VALUE; set.add(0); for(int i=0;i&lt;a.length;i++)&#123; sum+=a[i]; Integer v=set.ceiling(sum-k);//返回大于或等于给定的元素的最小元素，或null if(v!=null)&#123; max=Math.max(sum-v,max); &#125; set.add(sum); &#125; return max; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 393】UTF-8 Validation UTF-8 编码验证]]></title>
    <url>%2F2018%2F05%2F25%2F%5BLeetCode%20393%5DUTF-8%20Validation%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[[LeetCode 393]UTF-8 Validation UTF-8 编码验证Problem description:A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules: For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one’s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.This is how the UTF-8 encoding would work: 1234567Char. number range | UTF-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx Given an array of integers representing the data, return whether it is a valid utf-8 encoding. Note:The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data. Example1:1234data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.Return true.It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character. Example2:123456data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.Return false.The first 3 bits are all one&apos;s and the 4th bit is 0 means it is a 3-bytes character.The next byte is a continuation byte which starts with 10 and that&apos;s correct.But the second continuation byte does not start with 10, so it is invalid. 问题描述:UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则： 对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。 对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 这是 UTF-8 编码的工作方式： 1234567Char. number range | UTF-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。 说明：输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。 示例1:1234data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.返回 true 。这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。 示例2:123456data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.返回 false 。前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。下一个字节是开头为 10 的延续字节，这是正确的。但第二个延续字节不以 10 开头，所以是不符合规则的。 Solution: 一开始我理解出现错误认为只有一个utf-8编码让你判断，其实是判断一组连续的编码序列，也就是若干个utf-8序列。 不用位运算的方法，也就是将每个数据通过Integer.toBinaryString(data).toCharArray来判断。 更简洁的做法是直接通过位运算来记录1的位数，过程如下: data&gt;&gt;5==0b110 右移5位如果是0b110说明有2个字节，还有1个字节需要额外判断（ 或者data &amp; 0b11000000==0b11000000,与上述功能一致 ） data&gt;&gt;4==0b1110 右移4位如果是0b1110说明有3个字节，还有2个字节需要额外判断 data&gt;&gt;3==0b11110 右移3位如果是0b110说明有4个字节，还有3个字节需要额外判断 data&gt;&gt;7=0b1表示字符为10000000情况直接返回false 如果bitSize==1，表示当前为utf—8编码的第一个字符，做以上判断 如果bitSize!=1，表示当前正在判断10开头的字符，如果data[i]&gt;&gt;6!=0b10，直接返回false Code:123456789101112131415161718192021class Solution &#123; public boolean validUtf8(int[] data) &#123; int bitSize=1; for(int i=0;i&lt;data.length;i++)&#123; if(bitSize==1)&#123; if(data[i]&gt;&gt;5==0b110) bitSize=2; else if(data[i]&gt;&gt;4==0b1110) bitSize=3; else if(data[i]&gt;&gt;3==0b11110) bitSize=4; else if(data[i]&gt;&gt;7==0b1) return false;//10000000情况 &#125;else&#123; if(data[i]&gt;&gt;6!=0b10) return false; bitSize--; &#125; &#125; return bitSize==1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 48】Rotate Image 旋转图像]]></title>
    <url>%2F2018%2F05%2F24%2F%5BLeetCode%2048%5DRotate%20Image%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[[LeetCode 48]Rotate Image 旋转图像Problem description:You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note:You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1:12345678910111213Given input matrix =[ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2:123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]],rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 问题描述:给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明:你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例1:12345678910111213给定 matrix =[ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例2:123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]],原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] Solution:将矩阵沿着主对角线翻转一次，再沿着对称线旋转一次即可。 Code:123456789101112131415161718192021222324252627class Solution &#123; public void rotate(int[][] matrix) &#123; int n=matrix[0].length; int num=1; //沿着主对角线翻转 for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;num;j++)&#123; int temp=matrix[i][j]; matrix[i][j]=matrix[j][i]; matrix[j][i]=temp; &#125; num++; &#125; //沿着对称轴线翻转 for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n/2;j++)&#123; int temp=matrix[i][j]; matrix[i][j]=matrix[i][n-j-1]; matrix[i][n-j-1]=temp; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 78】Subsets 子集]]></title>
    <url>%2F2018%2F05%2F24%2F%5BLeetCode%2078%5DSubsets%20%E5%AD%90%E9%9B%86%2F</url>
    <content type="text"><![CDATA[[LeetCode 78]Subsets 子集Problem description:Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example:123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 问题描述:给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] Solution:Solution 1: 一个集合有n个元素，则其有2n的子集。 列出从0到2n-1的所有二进制，0表示不取对应元素，1表示取对应元素，即可得出所有子集。 123456789 1 2 3 Subset0 0 0 0 []1 0 0 1 32 0 1 0 23 0 1 1 234 1 0 0 15 1 0 1 136 1 1 0 127 1 1 1 123 Code:1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); int count=pow(2,nums.length); for(int i=0;i&lt;count;i++)&#123; char []bit=Integer.toBinaryString(i).toCharArray(); ArrayList&lt;Integer&gt; temp=new ArrayList&lt;Integer&gt;(); //从数组最后一位开始判断 for(int j=bit.length-1,k=nums.length-1;j&gt;=0;j--,k--)&#123; if(bit[j]=='1') temp.add(nums[k]); &#125; Collections.sort(temp); res.add(temp); temp=new ArrayList&lt;Integer&gt;(); &#125; return res; &#125; public int pow(int i,int n)&#123; int res=1; for(int k=0;k&lt;n;k++)&#123; res*=i; &#125; return res; &#125;&#125; Solution 2：深度优先算法，由于原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况，所以可以构造一棵二叉树，左子树表示选择该元素，右子树表示不选择，最终的叶节点就是所有子集合，树的结构如下： 12345678910 [] / \ / \ / \ [1] [] / \ / \ / \ / \ [1 2] [1] [2] [] / \ / \ / \ / \[1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] [] Code:123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; temp=new ArrayList&lt;Integer&gt;(); getSubList(nums,res,temp,0); return res; &#125; public void getSubList(int []nums,List&lt;List&lt;Integer&gt;&gt; res,ArrayList&lt;Integer&gt; temp,int pos)&#123; res.add(new ArrayList(temp));//注意要new一个ArrayList对象 for(int i=pos;i&lt;nums.length;i++)&#123; temp.add(nums[i]);//选择元素nums[i] getSubList(nums,res,temp,i+1);//下一个元素 temp.remove(temp.size()-1);//不选择nums[i] &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode 01】 Two Sum 两数之和]]></title>
    <url>%2F2018%2F05%2F24%2F%5BLeetCode%2001%5DTwo%20Sum%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[[LeetCode 01]Two Sum 两数之和Problem decription:Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 题目描述：给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例:123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] Solution： 排序数组，用两个头尾指针遍历即可，排序复杂度为O(nlogn),空间复杂度为O(1)； 利用map，以&lt;值,数组下标&gt;方式储存，再遍历数组即可； 这里采用第二种解法，要注意考虑数组中包含重复值的情况，在加入map的过程中要做判断； Code：123456789101112131415161718192021222324252627import java.util.HashMap;class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; h=new HashMap&lt;Integer,Integer&gt;(); int []result=new int[2]; boolean flag=true; for(int i=0;i&lt;nums.length;i++)&#123; if(h.containsKey(nums[i]) &amp;&amp; 2*nums[i]==target)&#123; result[0]=h.get(nums[i]); result[1]=i; flag=false;// 如果在加入时的重复值即为结果，则后面无需执行 &#125; h.put(nums[i],i); &#125; for(int j=0;j&lt;nums.length;j++)&#123; if(h.containsKey(target-nums[j]) &amp;&amp; target-nums[j]!=nums[j] &amp;&amp; flag)&#123; result[0]=j; result[1]=h.get(target-nums[j]); break; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown基本语法]]></title>
    <url>%2F2018%2F05%2F22%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[为了顺畅的在github pages上书写自己的blog，需要学习一些基本的MarkDown语法。 常用语法规则标题总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。快捷键：command + 1/2/3/4/5/6 换行只需在行末加两个空格键和一个回车键即可换行。快捷键：control + 回车键 文本样式123456加粗 - 快捷键：command + B 斜体 - 快捷键：command + I 删除线 - 快捷键：command + U 底纹 - 快捷键：command + K 下划线 - html：&lt;u&gt;text&lt;/u&gt;分割线 - 用*** 加粗 : hello* 斜体 * :hello~~ 删除线 ~~ :hello` 底纹 ` :hello分割线： 列表列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 无序列表 a b c 有序列表 a b c 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可 this is a quote 图片与链接图片为：![]() 链接为：[]() 在线插入：插入图片的地址需要图床，这里推荐围脖图床修复计划，生成URL 本地插入：![](本地路径) 插入图片 代码块使用三个`包裹代码即可 ,注意后面不要跟空格，hexo在生成网页时代码块之间匹配会出现问题 123var a = "hello world";var b = "hello world";]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github pages + hexo搭建博客]]></title>
    <url>%2F2018%2F05%2F22%2F%E4%BD%BF%E7%94%A8github%20pages%20%2B%20hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 目前比较热门的两种方式就是使用静态博客框架 jekyll 或者 hexo，相对于jekyll，hexo主题丰富，第三方插件优秀，配置简单，最主要的一点，hexo的开发文档阅读感受较jekyll来说更舒服。 一.环境搭建 官方文档非常详细 hexo documents 这里以MacOs为例 github账号注册地址 安装Node.js cURL:$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget:$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后重启终端：$ nvm install stable 这里推荐下载安装程序来安装 安装git$ brew install git 安装 Hexo$ npm install -g hexo-cli 二.建站123$ hexo init &lt;folderName&gt;$ cd &lt;folderName&gt;$ npm install 安装完成后文件目录结构如下： 12345678├── \_config.yml├── package.json├── scaffolds├── source| ├── \_drafts| └── \_posts└── themes 你可以在_config.yml中配置大部分网站设置。 其他一些Hexo常用命令： 1234567hexo n # 新建文章，在\source\_posts文件夹里hexo new page # 新建页面，比如想在导航栏新增一个“关于我”的页面hexo clean # 清除本地的数据库和生成的public文件夹hexo g # 生成博客文件hexo s # 运行在本地浏览器，可当预览使用hexo d # 部署博客到Github等 三.创建Repo 新建一个repo，注意名称一定是your_username.github.io这样的格式。 进入刚新建的仓库，点击Setting，一直拖到最下面，选择Automatic Page Generator，随便选个主题然后发布即可。 在站点_config.yml文件中任意位置添加以下代码段： 12345deploy: type: git # 填上你自己的仓库名，注意后面有`.git` repository: git@github.com:your_username/your_username.github.io.git branch: master 注意每个：后面都要跟一个空格！ 安装部署所需：$ npm install hexo-deployer-git --save 四.主题 创建 Hexo 主题非常容易，您只要在 themes 文件夹内，新增一个任意名称的文件夹，并修改 _config.yml 内的 theme 设定，即可切换主题。一个主题可能会有以下的结构： 123456.├── \_config.yml(配置是无需重启服务器会自动更新)├── languages├── layout├── scripts└── source 这里推荐使用最多的nexT 主题 五.新建页面新建分类页面：hexo new page categories 打开../source/categories/index.md 编辑相对应的type 123456---title: 分类date: 2018-05-21 22:00:35type: &quot;categories&quot;comments: false--- 在站点_config.yml中更改menu下代码，如果没有添加 categories: /categories/ 新建导航默认导航栏只有首页、归档、标签、分类四项。如果想增加其他如C++、随笔等。需要打开\themes\next_config.yml找到如下 123456789101112#When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / categories: /categories tags: /tags archives: /archives #这里是新增的，Coding是一级目录，C是二级目录，同理随笔是一级目录 c++: /categories/Coding/C/ python: /categories/Coding/Python/ essay: /categories/随笔/ #注意这里没有/categories about: /about that‘s all！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
</search>
